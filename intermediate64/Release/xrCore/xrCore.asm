; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_0L@KNAPJNOA@xrCore?4dll?$AA@		; `string'
PUBLIC	??_C@_03OOPKOFPE@?9wf?$AA@			; `string'
PUBLIC	??_C@_06EPKOIJFL@?$CF?$FL?$FO?5?$FN?5?$AA@	; `string'
PUBLIC	??_C@_04CPLKOIEC@?9wf?5?$AA@			; `string'
PUBLIC	??_C@_0L@FOPADGPO@?9mem_debug?$AA@		; `string'
PUBLIC	??_C@_06LOIFJNFN@?9build?$AA@			; `string'
PUBLIC	??_C@_07FDFMNBND@?9ebuild?$AA@			; `string'
PUBLIC	??_C@_0P@FKEDFFFF@?9file_activity?$AA@		; `string'
PUBLIC	??_C@_06MIBHPEBH@xrCore?$AA@			; `string'
PUBLIC	??_C@_0BD@JOAIEFKH@?8?$CFs?8?5build?5?$CFd?0?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@KCKDNGEA@EnumerateLoadedModulesEx?$AA@ ; `string'
PUBLIC	??_C@_0M@OOEJBPPK@dbghelp?4dll?$AA@		; `string'
PUBLIC	??_C@_0EG@KOOKGMKK@?S?q?r?$OA?p?e?b?x?h?i?5?t?$OA?i?k?5dbghelp?4dll?5?$CI?$CFd?4@ ; `string'
PUBLIC	??_C@_0BB@IILKFANF@DebugHlp?5Warning?$AA@	; `string'
PUBLIC	??_R2CSymbolEngine@@8				; CSymbolEngine::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSymbolEngine@@8			; CSymbolEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CSymbolEngine@@8				; CSymbolEngine::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCSymbolEngine@@@8			; CSymbolEngine `RTTI Type Descriptor'
PUBLIC	??_R4CSymbolEngine@@6B@				; CSymbolEngine::`RTTI Complete Object Locator'
PUBLIC	?build_date@@3PEBDEB				; build_date
PUBLIC	?build_id@@3IA					; build_id
PUBLIC	?Core@@3VxrCore@@A				; Core
PUBLIC	??_7CSymbolEngine@@6B@				; CSymbolEngine::`vftable'
EXTRN	__imp_timeBeginPeriod:PROC
EXTRN	__imp__control87:PROC
EXTRN	__imp__clearfp:PROC
EXTRN	__imp_MessageBoxA:PROC
EXTRN	__imp_sprintf_s:PROC
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_ImagehlpApiVersion:PROC
EXTRN	__imp_GetComputerNameA:PROC
EXTRN	__imp_GetUserNameA:PROC
EXTRN	__imp_GetCurrentDirectoryA:PROC
EXTRN	__imp_SetCurrentDirectoryA:PROC
EXTRN	__imp_sscanf:PROC
EXTRN	__imp_strstr:PROC
EXTRN	__imp_strcat_s:PROC
EXTRN	__imp__splitpath:PROC
EXTRN	__imp__strlwr_s:PROC
EXTRN	__imp_GetCommandLineA:PROC
EXTRN	__imp_strcpy_s:PROC
EXTRN	__imp_CoInitializeEx:PROC
EXTRN	__imp_VerQueryValueA:PROC
EXTRN	__imp_GetFileVersionInfoA:PROC
EXTRN	__imp_GetFileVersionInfoSizeA:PROC
EXTRN	__imp_GetModuleFileNameA:PROC
EXTRN	__imp_GetModuleHandleA:PROC
init_counter DD	01H DUP (?)
?build_date@@3PEBDEB DQ 01H DUP (?)			; build_date
?build_id@@3IA DD 01H DUP (?)				; build_id
?Core@@3VxrCore@@A DB 06d0H DUP (?)			; Core
_BSS	ENDS
;	COMDAT ??_7CSymbolEngine@@6B@
CONST	SEGMENT
??_7CSymbolEngine@@6B@ DQ FLAT:??_R4CSymbolEngine@@6B@	; CSymbolEngine::`vftable'
	DQ	FLAT:??_ECSymbolEngine@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R4CSymbolEngine@@6B@
rdata$r	SEGMENT
??_R4CSymbolEngine@@6B@ DD 01H				; CSymbolEngine::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVCSymbolEngine@@@8
	DD	imagerel ??_R3CSymbolEngine@@8
	DD	imagerel ??_R4CSymbolEngine@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVCSymbolEngine@@@8
data$r	SEGMENT
??_R0?AVCSymbolEngine@@@8 DQ FLAT:??_7type_info@@6B@	; CSymbolEngine `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVCSymbolEngine@@', 00H
data$r	ENDS
;	COMDAT ??_R3CSymbolEngine@@8
rdata$r	SEGMENT
??_R3CSymbolEngine@@8 DD 00H				; CSymbolEngine::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2CSymbolEngine@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CSymbolEngine@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSymbolEngine@@8 DD imagerel ??_R0?AVCSymbolEngine@@@8 ; CSymbolEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CSymbolEngine@@8
rdata$r	ENDS
;	COMDAT ??_R2CSymbolEngine@@8
rdata$r	SEGMENT
??_R2CSymbolEngine@@8 DD imagerel ??_R1A@?0A@EA@CSymbolEngine@@8 ; CSymbolEngine::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_C@_0BB@IILKFANF@DebugHlp?5Warning?$AA@
CONST	SEGMENT
??_C@_0BB@IILKFANF@DebugHlp?5Warning?$AA@ DB 'DebugHlp Warning', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@KOOKGMKK@?S?q?r?$OA?p?e?b?x?h?i?5?t?$OA?i?k?5dbghelp?4dll?5?$CI?$CFd?4@
CONST	SEGMENT
??_C@_0EG@KOOKGMKK@?S?q?r?$OA?p?e?b?x?h?i?5?t?$OA?i?k?5dbghelp?4dll?5?$CI?$CFd?4@ DB 0d3H
	DB	0f1H, 0f2H, 0e0H, 0f0H, 0e5H, 0e2H, 0f8H, 0e8H, 0e9H, ' ', 0f4H
	DB	0e0H, 0e9H, 0ebH, ' dbghelp.dll (%d.%d.%d.%d), ', 0e5H, 0e3H, 0eeH
	DB	' ', 0f0H, 0e5H, 0eaH, 0eeH, 0ecH, 0e5H, 0edH, 0e4H, 0f3H, 0e5H
	DB	0f2H, 0f1H, 0ffH, ' ', 0f3H, 0e4H, 0e0H, 0ebH, 0e8H, 0f2H, 0fcH
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OOEJBPPK@dbghelp?4dll?$AA@
CONST	SEGMENT
??_C@_0M@OOEJBPPK@dbghelp?4dll?$AA@ DB 'dbghelp.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KCKDNGEA@EnumerateLoadedModulesEx?$AA@
CONST	SEGMENT
??_C@_0BJ@KCKDNGEA@EnumerateLoadedModulesEx?$AA@ DB 'EnumerateLoadedModul'
	DB	'esEx', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JOAIEFKH@?8?$CFs?8?5build?5?$CFd?0?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@JOAIEFKH@?8?$CFs?8?5build?5?$CFd?0?5?$CFs?6?$AA@ DB '''%s'' bui'
	DB	'ld %d, %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MIBHPEBH@xrCore?$AA@
CONST	SEGMENT
??_C@_06MIBHPEBH@xrCore?$AA@ DB 'xrCore', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FKEDFFFF@?9file_activity?$AA@
CONST	SEGMENT
??_C@_0P@FKEDFFFF@?9file_activity?$AA@ DB '-file_activity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FDFMNBND@?9ebuild?$AA@
CONST	SEGMENT
??_C@_07FDFMNBND@?9ebuild?$AA@ DB '-ebuild', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LOIFJNFN@?9build?$AA@
CONST	SEGMENT
??_C@_06LOIFJNFN@?9build?$AA@ DB '-build', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FOPADGPO@?9mem_debug?$AA@
CONST	SEGMENT
??_C@_0L@FOPADGPO@?9mem_debug?$AA@ DB '-mem_debug', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CPLKOIEC@?9wf?5?$AA@
CONST	SEGMENT
??_C@_04CPLKOIEC@?9wf?5?$AA@ DB '-wf ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EPKOIJFL@?$CF?$FL?$FO?5?$FN?5?$AA@
CONST	SEGMENT
??_C@_06EPKOIJFL@?$CF?$FL?$FO?5?$FN?5?$AA@ DB '%[^ ] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OOPKOFPE@?9wf?$AA@
CONST	SEGMENT
??_C@_03OOPKOFPE@?9wf?$AA@ DB '-wf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KNAPJNOA@xrCore?4dll?$AA@
CONST	SEGMENT
??_C@_0L@KNAPJNOA@xrCore?4dll?$AA@ DB 'xrCore.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
PUBLIC	??_U@YAPEAX_K@Z					; operator new[]
PUBLIC	?strconcat@@YAPEBDHPEADPEBD1@Z			; strconcat
PUBLIC	?strstr@@YAPEADPEADPEBD@Z			; strstr
PUBLIC	??_GCLocatorAPI@@QEAAPEAXI@Z			; CLocatorAPI::`scalar deleting destructor'
PUBLIC	??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z ; xr_special_free<0,compression::ppmd::stream>::operator()
PUBLIC	??R?$xr_special_free@$00VEFS_Utils@@@@QEAAXAEAPEAVEFS_Utils@@@Z ; xr_special_free<1,EFS_Utils>::operator()
PUBLIC	??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z ; xr_special_free<0,CLocatorAPI>::operator()
PUBLIC	??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z ; xr_delete<compression::ppmd::stream>
PUBLIC	??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z ; xr_delete<EFS_Utils>
PUBLIC	??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z ; xr_delete<CLocatorAPI>
PUBLIC	??$xr_new@VEFS_Utils@@@@YAPEAVEFS_Utils@@XZ	; xr_new<EFS_Utils>
PUBLIC	??$xr_new@VCLocatorAPI@@@@YAPEAVCLocatorAPI@@XZ	; xr_new<CLocatorAPI>
PUBLIC	??$strcpy_s@$0EA@@@YAHAEAY0EA@DPEBD@Z		; strcpy_s<64>
PUBLIC	DllMain
PUBLIC	?_destroy@xrCore@@QEAAXXZ			; xrCore::_destroy
PUBLIC	?buffer@stream@ppmd@compression@@QEBAPEAEXZ	; compression::ppmd::stream::buffer
PUBLIC	?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z	; xrCore::_initialize
PUBLIC	??_GCSymbolEngine@@UEAAPEAXI@Z			; CSymbolEngine::`scalar deleting destructor'
PUBLIC	?GetInMemoryFileVersion@CSymbolEngine@@QEAAHPEBDAEAK1@Z ; CSymbolEngine::GetInMemoryFileVersion
PUBLIC	??1CSymbolEngine@@UEAA@XZ			; CSymbolEngine::~CSymbolEngine
PUBLIC	??0CSymbolEngine@@QEAA@XZ			; CSymbolEngine::CSymbolEngine
EXTRN	??_ECSymbolEngine@@UEAAPEAXI@Z:PROC		; CSymbolEngine::`vector deleting destructor'
;	COMDAT pdata
pdata	SEGMENT
$pdata$?strconcat@@YAPEBDHPEADPEBD1@Z DD imagerel $LN7
	DD	imagerel $LN7+95
	DD	imagerel $unwind$?strconcat@@YAPEBDHPEADPEBD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCLocatorAPI@@QEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+23
	DD	imagerel $unwind$??_GCLocatorAPI@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z DD imagerel $LN29
	DD	imagerel $LN29+67
	DD	imagerel $unwind$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z DD imagerel $LN29+67
	DD	imagerel $LN29+111
	DD	imagerel $chain$0$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z DD imagerel $LN29+111
	DD	imagerel $LN29+117
	DD	imagerel $chain$1$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$xr_special_free@$00VEFS_Utils@@@@QEAAXAEAPEAVEFS_Utils@@@Z DD imagerel $LN29
	DD	imagerel $LN29+141
	DD	imagerel $unwind$??R?$xr_special_free@$00VEFS_Utils@@@@QEAAXAEAPEAVEFS_Utils@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z DD imagerel $LN34
	DD	imagerel $LN34+79
	DD	imagerel $unwind$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z DD imagerel $LN34+79
	DD	imagerel $LN34+123
	DD	imagerel $chain$0$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z DD imagerel $LN34+123
	DD	imagerel $LN34+129
	DD	imagerel $chain$1$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z DD imagerel $LN32
	DD	imagerel $LN32+83
	DD	imagerel $unwind$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z DD imagerel $LN32+83
	DD	imagerel $LN32+127
	DD	imagerel $chain$0$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z DD imagerel $LN32+127
	DD	imagerel $LN32+144
	DD	imagerel $chain$1$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z DD imagerel $LN32
	DD	imagerel $LN32+20
	DD	imagerel $unwind$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z DD imagerel $LN32+20
	DD	imagerel $LN32+155
	DD	imagerel $chain$1$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z DD imagerel $LN32+155
	DD	imagerel $LN32+160
	DD	imagerel $chain$2$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z DD imagerel $LN37
	DD	imagerel $LN37+16
	DD	imagerel $unwind$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z DD imagerel $LN37+16
	DD	imagerel $LN37+83
	DD	imagerel $chain$0$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z DD imagerel $LN37+83
	DD	imagerel $LN37+127
	DD	imagerel $chain$1$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z DD imagerel $LN37+127
	DD	imagerel $LN37+143
	DD	imagerel $chain$2$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z DD imagerel $LN37+143
	DD	imagerel $LN37+148
	DD	imagerel $chain$3$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VEFS_Utils@@@@YAPEAVEFS_Utils@@XZ DD imagerel $LN26
	DD	imagerel $LN26+81
	DD	imagerel $unwind$??$xr_new@VEFS_Utils@@@@YAPEAVEFS_Utils@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VCLocatorAPI@@@@YAPEAVCLocatorAPI@@XZ DD imagerel $LN8
	DD	imagerel $LN8+43
	DD	imagerel $unwind$??$xr_new@VCLocatorAPI@@@@YAPEAVCLocatorAPI@@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$DllMain DD imagerel $LN12
	DD	imagerel $LN12+112
	DD	imagerel $unwind$DllMain
$pdata$?_destroy@xrCore@@QEAAXXZ DD imagerel $LN18
	DD	imagerel $LN18+153
	DD	imagerel $unwind$?_destroy@xrCore@@QEAAXXZ
$pdata$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD imagerel $LN101
	DD	imagerel $LN101+10
	DD	imagerel $unwind$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$pdata$0$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD imagerel $LN101+10
	DD	imagerel $LN101+14
	DD	imagerel $chain$0$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$pdata$4$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD imagerel $LN101+14
	DD	imagerel $LN101+71
	DD	imagerel $chain$4$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$pdata$5$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD imagerel $LN101+71
	DD	imagerel $LN101+79
	DD	imagerel $chain$5$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$pdata$6$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD imagerel $LN101+79
	DD	imagerel $LN101+335
	DD	imagerel $chain$6$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$pdata$7$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD imagerel $LN101+335
	DD	imagerel $LN101+561
	DD	imagerel $chain$7$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$pdata$8$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD imagerel $LN101+561
	DD	imagerel $LN101+669
	DD	imagerel $chain$8$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$pdata$9$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD imagerel $LN101+669
	DD	imagerel $LN101+899
	DD	imagerel $chain$9$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$pdata$10$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD imagerel $LN101+899
	DD	imagerel $LN101+1027
	DD	imagerel $chain$10$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCSymbolEngine@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+48
	DD	imagerel $unwind$??_GCSymbolEngine@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetInMemoryFileVersion@CSymbolEngine@@QEAAHPEBDAEAK1@Z DD imagerel $LN63
	DD	imagerel $LN63+292
	DD	imagerel $unwind$?GetInMemoryFileVersion@CSymbolEngine@@QEAAHPEBDAEAK1@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetInMemoryFileVersion@CSymbolEngine@@QEAAHPEBDAEAK1@Z DD 078201H
	DD	0273482H
	DD	0280115H
	DD	0700ce00eH
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCSymbolEngine@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
xdata	SEGMENT
$unwind$DllMain DD 010401H
	DD	04204H
$unwind$?_destroy@xrCore@@QEAAXXZ DD 010401H
	DD	04204H
$unwind$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD 020a01H
	DD	0135010aH
$chain$0$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD 020421H
	DD	01373404H
	DD	imagerel $LN101
	DD	imagerel $LN101+10
	DD	imagerel $unwind$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$chain$4$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD 081021H
	DD	0132c410H
	DD	0133740cH
	DD	01346408H
	DD	01385404H
	DD	imagerel $LN101+10
	DD	imagerel $LN101+14
	DD	imagerel $chain$0$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$chain$5$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD 020821H
	DD	0131e408H
	DD	imagerel $LN101+14
	DD	imagerel $LN101+71
	DD	imagerel $chain$4$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$chain$6$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD 020821H
	DD	0130f408H
	DD	imagerel $LN101+71
	DD	imagerel $LN101+79
	DD	imagerel $chain$5$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$chain$7$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD 021H
	DD	imagerel $LN101+71
	DD	imagerel $LN101+79
	DD	imagerel $chain$5$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$chain$8$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD 021H
	DD	imagerel $LN101+14
	DD	imagerel $LN101+71
	DD	imagerel $chain$4$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$chain$9$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD 060021H
	DD	0132c400H
	DD	01337400H
	DD	01346400H
	DD	imagerel $LN101+10
	DD	imagerel $LN101+14
	DD	imagerel $chain$0$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
$chain$10$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z DD 021H
	DD	imagerel $LN101
	DD	imagerel $LN101+10
	DD	imagerel $unwind$?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VCLocatorAPI@@@@YAPEAVCLocatorAPI@@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VEFS_Utils@@@@YAPEAVEFS_Utils@@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+16
	DD	imagerel $unwind$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z DD 021H
	DD	imagerel $LN37+16
	DD	imagerel $LN37+83
	DD	imagerel $chain$0$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN37+16
	DD	imagerel $LN37+83
	DD	imagerel $chain$0$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z DD 020521H
	DD	047405H
	DD	imagerel $LN37
	DD	imagerel $LN37+16
	DD	imagerel $unwind$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+20
	DD	imagerel $unwind$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z DD 040a21H
	DD	04740aH
	DD	063405H
	DD	imagerel $LN32
	DD	imagerel $LN32+20
	DD	imagerel $unwind$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+83
	DD	imagerel $unwind$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN32
	DD	imagerel $LN32+83
	DD	imagerel $unwind$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+79
	DD	imagerel $unwind$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN34
	DD	imagerel $LN34+79
	DD	imagerel $unwind$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$xr_special_free@$00VEFS_Utils@@@@QEAAXAEAPEAVEFS_Utils@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+67
	DD	imagerel $unwind$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN29
	DD	imagerel $LN29+67
	DD	imagerel $unwind$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCLocatorAPI@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?strconcat@@YAPEBDHPEADPEBD1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h
;	COMDAT ??0CSymbolEngine@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0CSymbolEngine@@QEAA@XZ PROC				; CSymbolEngine::CSymbolEngine, COMDAT

; 77   :     CSymbolEngine ( void )

	lea	rax, OFFSET FLAT:??_7CSymbolEngine@@6B@
	mov	QWORD PTR [rcx], rax

; 78   :     {
; 79   :     }

	mov	rax, rcx
	ret	0
??0CSymbolEngine@@QEAA@XZ ENDP				; CSymbolEngine::CSymbolEngine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h
;	COMDAT ??1CSymbolEngine@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1CSymbolEngine@@UEAA@XZ PROC				; CSymbolEngine::~CSymbolEngine, COMDAT

; 82   :     {

	lea	rax, OFFSET FLAT:??_7CSymbolEngine@@6B@
	mov	QWORD PTR [rcx], rax

; 83   :     }

	ret	0
??1CSymbolEngine@@UEAA@XZ ENDP				; CSymbolEngine::~CSymbolEngine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h
;	COMDAT ?GetInMemoryFileVersion@CSymbolEngine@@QEAAHPEBDAEAK1@Z
_TEXT	SEGMENT
szImageHlp$ = 32
this$dead$ = 352
uiLen$ = 352
szFile$dead$ = 360
dwVerInfoHandle$ = 360
p$ = 368
p$ = 368
dwMS$ = 368
lpVerInfo$ = 376
dwLS$ = 376
?GetInMemoryFileVersion@CSymbolEngine@@QEAAHPEBDAEAK1@Z PROC ; CSymbolEngine::GetInMemoryFileVersion, COMDAT

; 139  :     {

$LN63:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 320				; 00000140H

; 140  :         HMODULE hInstIH = GetModuleHandle ( szFile ) ;

	lea	rcx, OFFSET FLAT:??_C@_0M@OOEJBPPK@dbghelp?4dll?$AA@
	mov	rsi, r9
	mov	r14, r8
	call	QWORD PTR __imp_GetModuleHandleA

; 141  : 
; 142  :         // Get the full filename of the loaded version.
; 143  :         TCHAR szImageHlp[ MAX_PATH ] ;
; 144  :         GetModuleFileName ( hInstIH , szImageHlp , MAX_PATH ) ;

	lea	rdx, QWORD PTR szImageHlp$[rsp]
	mov	r8d, 260				; 00000104H
	mov	rcx, rax
	call	QWORD PTR __imp_GetModuleFileNameA

; 145  : 
; 146  :         dwMS = 0 ;

	xor	eax, eax

; 147  :         dwLS = 0 ;
; 148  : 
; 149  :         // Get the version information size.
; 150  :         DWORD dwVerInfoHandle ;
; 151  :         DWORD dwVerSize       ;
; 152  : 
; 153  :         dwVerSize = GetFileVersionInfoSize ( szImageHlp       ,
; 154  :                                              &dwVerInfoHandle  ) ;

	lea	rdx, QWORD PTR dwVerInfoHandle$[rsp]
	mov	DWORD PTR [r14], eax
	lea	rcx, QWORD PTR szImageHlp$[rsp]
	mov	DWORD PTR [rsi], eax
	call	QWORD PTR __imp_GetFileVersionInfoSizeA
	mov	edi, eax

; 155  :         if ( 0 == dwVerSize )

	test	eax, eax
	jne	SHORT $LN3@GetInMemor

; 186  :     }

	add	rsp, 320				; 00000140H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN3@GetInMemor:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 128  : 	IC void*	operator new[]		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	test	eax, eax
	mov	edx, 1
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	cmovne	rdx, rdi
	mov	QWORD PTR [rsp+312], rbx
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h

; 165  :                                            lpData            ) )

	mov	edx, DWORD PTR dwVerInfoHandle$[rsp]
	lea	rcx, QWORD PTR szImageHlp$[rsp]
	mov	r9, rax
	mov	r8d, edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 128  : 	IC void*	operator new[]		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	mov	rbx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h

; 165  :                                            lpData            ) )

	call	QWORD PTR __imp_GetFileVersionInfoA
	test	eax, eax
	jne	SHORT $LN2@GetInMemor
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 129  : 	IC void		operator delete[]	(void* p)			{	xr_free(p);											}

	lea	rcx, QWORD PTR p$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h

; 167  :             delete [] lpData ;

	mov	QWORD PTR p$[rsp], rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 129  : 	IC void		operator delete[]	(void* p)			{	xr_free(p);											}

	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h

; 168  :             return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN61@GetInMemor
$LN2@GetInMemor:

; 169  :         }
; 170  : 
; 171  :         VS_FIXEDFILEINFO * lpVerInfo ;
; 172  :         UINT uiLen ;
; 173  :         BOOL bRet = VerQueryValue ( lpData              ,
; 174  :                                     _T ( "\\" )         ,
; 175  :                                     (LPVOID*)&lpVerInfo ,
; 176  :                                     &uiLen               ) ;

	lea	r9, QWORD PTR uiLen$[rsp]
	lea	r8, QWORD PTR lpVerInfo$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_01KICIPPFI@?2?$AA@
	mov	rcx, rbx
	call	QWORD PTR __imp_VerQueryValueA
	mov	edi, eax

; 177  :         if ( TRUE == bRet )

	cmp	eax, 1
	jne	SHORT $LN1@GetInMemor

; 178  :         {
; 179  :             dwMS = lpVerInfo->dwFileVersionMS ;

	mov	rdx, QWORD PTR lpVerInfo$[rsp]
	mov	ecx, DWORD PTR [rdx+8]
	mov	DWORD PTR [r14], ecx

; 180  :             dwLS = lpVerInfo->dwFileVersionLS ;

	mov	ecx, DWORD PTR [rdx+12]
	mov	DWORD PTR [rsi], ecx
$LN1@GetInMemor:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 129  : 	IC void		operator delete[]	(void* p)			{	xr_free(p);											}

	lea	rcx, QWORD PTR p$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h

; 183  :         delete [] lpData ;

	mov	QWORD PTR p$[rsp], rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 129  : 	IC void		operator delete[]	(void* p)			{	xr_free(p);											}

	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h

; 185  :         return ( bRet ) ;

	mov	eax, edi
$LN61@GetInMemor:
	mov	rbx, QWORD PTR [rsp+312]

; 186  :     }

	add	rsp, 320				; 00000140H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?GetInMemoryFileVersion@CSymbolEngine@@QEAAHPEBDAEAK1@Z ENDP ; CSymbolEngine::GetInMemoryFileVersion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??_GCSymbolEngine@@UEAAPEAXI@Z
_TEXT	SEGMENT
p$ = 48
this$ = 48
__flags$ = 56
??_GCSymbolEngine@@UEAAPEAXI@Z PROC			; CSymbolEngine::`scalar deleting destructor', COMDAT
$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\symbolengine.h

; 82   :     {

	lea	rax, OFFSET FLAT:??_7CSymbolEngine@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN8@scalar
	mov	QWORD PTR p$[rsp], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 127  : 	IC void		operator delete		(void *p)			{	xr_free(p);											}

	lea	rcx, QWORD PTR p$[rsp]
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
$LN8@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GCSymbolEngine@@UEAAPEAXI@Z ENDP			; CSymbolEngine::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
_TEXT	SEGMENT
msg$1 = 64
dr$2 = 320
fn$3 = 848
di$4 = 1376
c_name$5 = 1904
dwVer$6 = 2480
sz_comp$7 = 2480
this$ = 2480
_ApplicationName$ = 2488
cb$ = 2496
sz_user$8 = 2504
init_fs$ = 2504
fs_fname$ = 2512
?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z PROC		; xrCore::_initialize

; 34   : {

$LN101:
	mov	rax, rsp
	sub	rsp, 2472				; 000009a8H
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax-8], rsi
	mov	QWORD PTR [rax-16], rdi
	mov	QWORD PTR [rax-24], r12
	mov	r12, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	mov	r8, rdx
	mov	edx, 64					; 00000040H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 34   : {

	mov	ebp, r9d
	mov	rsi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	call	QWORD PTR __imp_strcpy_s
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 36   : 	if (0==init_counter) {

	xor	ebx, ebx
	cmp	DWORD PTR init_counter, ebx
	jne	$LN63@initialize

; 37   : #ifdef XRCORE_STATIC	
; 38   : 		_clear87	();
; 39   : 		_control87	( _PC_53,   MCW_PC );
; 40   : 		_control87	( _RC_CHOP, MCW_RC );
; 41   : 		_control87	( _RC_NEAR, MCW_RC );
; 42   : 		_control87	( _MCW_EM,  MCW_EM );
; 43   : #endif
; 44   : 		// Init COM so we can use CoCreateInstance
; 45   : //		HRESULT co_res = 
; 46   : 			CoInitializeEx (NULL, COINIT_MULTITHREADED);

	xor	edx, edx
	xor	ecx, ecx
	mov	QWORD PTR [rsp+2440], r14
	mov	QWORD PTR [rsp+2432], r15
	call	QWORD PTR __imp_CoInitializeEx

; 47   : 
; 48   : 		strcpy_s			(Params,sizeof(Params),GetCommandLine());

	call	QWORD PTR __imp_GetCommandLineA
	lea	rcx, QWORD PTR [rsi+1232]
	mov	r8, rax
	mov	edx, 512				; 00000200H
	call	QWORD PTR __imp_strcpy_s

; 49   : 		_strlwr_s			(Params,sizeof(Params));

	lea	rcx, QWORD PTR [rsi+1232]
	mov	edx, 512				; 00000200H
	call	QWORD PTR __imp__strlwr_s

; 50   : 
; 51   : 		string_path		fn,dr,di;
; 52   : 
; 53   : 		// application path
; 54   :         GetModuleFileName(GetModuleHandle(MODULE_NAME),fn,sizeof(fn));

	lea	rcx, OFFSET FLAT:??_C@_0L@KNAPJNOA@xrCore?4dll?$AA@
	call	QWORD PTR __imp_GetModuleHandleA
	lea	rdx, QWORD PTR fn$3[rsp]
	mov	r8d, 520				; 00000208H
	mov	rcx, rax
	call	QWORD PTR __imp_GetModuleFileNameA

; 55   :         _splitpath		(fn,dr,di,0,0);

	lea	r8, QWORD PTR di$4[rsp]
	lea	rdx, QWORD PTR dr$2[rsp]
	lea	rcx, QWORD PTR fn$3[rsp]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	call	QWORD PTR __imp__splitpath
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rax, QWORD PTR dr$2[rsp]
	or	rdi, -1
$LL98@initialize:
	inc	rdi
	cmp	BYTE PTR [rax+rdi], bl
	jne	SHORT $LL98@initialize

; 173  : 	strcpy_s(dest,dest_sz,S1);

	lea	r8, QWORD PTR dr$2[rsp]
	lea	rcx, QWORD PTR [rsi+64]
	mov	edx, 520				; 00000208H
	call	QWORD PTR __imp_strcpy_s

; 174  : 	strcat_s(dest,dest_sz-l1,S2);

	mov	edx, 520				; 00000208H
	lea	r8, QWORD PTR di$4[rsp]
	lea	rcx, QWORD PTR [rsi+64]
	sub	edx, edi
	call	QWORD PTR __imp_strcat_s
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 58   : 		strcpy_s		(g_application_path,sizeof(g_application_path),ApplicationPath);

	lea	r8, QWORD PTR [rsi+64]
	lea	rcx, OFFSET FLAT:?g_application_path@@3PADA ; g_application_path
	mov	edx, 256				; 00000100H
	call	QWORD PTR __imp_strcpy_s
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_03OOPKOFPE@?9wf?$AA@
	lea	rcx, QWORD PTR [rsi+1232]
	call	QWORD PTR __imp_strstr
	mov	r15, QWORD PTR [rsp+2432]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 62   :         if( strstr(Params,"-wf") )

	test	rax, rax
	je	SHORT $LN9@initialize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_04CPLKOIEC@?9wf?5?$AA@
	lea	rcx, OFFSET FLAT:?Core@@3VxrCore@@A+1232
	call	QWORD PTR __imp_strstr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 65   :             sscanf					(strstr(Core.Params,"-wf ")+4,"%[^ ] ",c_name);

	lea	r8, QWORD PTR c_name$5[rsp]
	lea	rdx, OFFSET FLAT:??_C@_06EPKOIJFL@?$CF?$FL?$FO?5?$FN?5?$AA@
	lea	rcx, QWORD PTR [rax+4]
	call	QWORD PTR __imp_sscanf

; 66   :             SetCurrentDirectory     (c_name);

	lea	rcx, QWORD PTR c_name$5[rsp]
	call	QWORD PTR __imp_SetCurrentDirectoryA
$LN9@initialize:

; 67   : 
; 68   :         }
; 69   : 		GetCurrentDirectory(sizeof(WorkingPath),WorkingPath);

	lea	rdx, QWORD PTR [rsi+584]
	mov	ecx, 520				; 00000208H
	call	QWORD PTR __imp_GetCurrentDirectoryA

; 70   : 
; 71   : 		// User/Comp Name
; 72   : 		DWORD	sz_user		= sizeof(UserName);
; 73   : 		GetUserName			(UserName,&sz_user);

	lea	rcx, QWORD PTR [rsi+1104]
	lea	rdx, QWORD PTR sz_user$8[rsp]
	mov	DWORD PTR sz_user$8[rsp], 64		; 00000040H
	call	QWORD PTR __imp_GetUserNameA

; 74   : 
; 75   : 		DWORD	sz_comp		= sizeof(CompName);
; 76   : 		GetComputerName		(CompName,&sz_comp);

	lea	rcx, QWORD PTR [rsi+1168]
	lea	rdx, QWORD PTR sz_comp$7[rsp]
	mov	DWORD PTR sz_comp$7[rsp], 64		; 00000040H
	call	QWORD PTR __imp_GetComputerNameA

; 77   : 
; 78   : 		// Mathematics & PSI detection
; 79   : 		CPU::Detect			();

	call	?Detect@CPU@@YAXXZ			; CPU::Detect
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_0L@FOPADGPO@?9mem_debug?$AA@
	lea	rcx, QWORD PTR [rsi+1232]
	call	QWORD PTR __imp_strstr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 81   : 		Memory._initialize	(strstr(Params,"-mem_debug") ? TRUE : FALSE);

	mov	edx, ebx
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	test	rax, rax
	setne	dl
	call	?_initialize@xrMemory@@QEAAXH@Z		; xrMemory::_initialize

; 82   : 
; 83   : 		DUMP_PHASE;
; 84   : 
; 85   : 		InitLog				();

	call	?InitLog@@YAXXZ				; InitLog

; 86   : 		_initialize_cpu		();

	call	?_initialize_cpu@@YAXXZ			; _initialize_cpu
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 128				; 00000080H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	r14, QWORD PTR [rsp+2440]

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN56@initialize
	mov	rcx, rax
	call	??0CLocatorAPI@@QEAA@XZ			; CLocatorAPI::CLocatorAPI
	mov	QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA, rax ; xr_FS
	jmp	SHORT $LN57@initialize
$LN56@initialize:
	mov	QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA, rbx ; xr_FS
$LN57@initialize:

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 24
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	rdi, rax

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN62@initialize
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 14   : {

	lea	rax, OFFSET FLAT:??_7EFS_Utils@@6B@
	mov	QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

	mov	QWORD PTR [rdi+8], rbx

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR [rdi+16], rbx

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> > const ,void * __ptr64>,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > > >::_Buyheadnode
	mov	QWORD PTR [rdi+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	QWORD PTR ?xr_EFS@@3PEAVEFS_Utils@@EA, rdi ; xr_EFS
	jmp	SHORT $LN63@initialize
$LN62@initialize:
	mov	QWORD PTR ?xr_EFS@@3PEAVEFS_Utils@@EA, rbx ; xr_EFS
$LN63@initialize:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 97   : 	if (init_fs){

	test	ebp, ebp
	mov	rbp, QWORD PTR [rsp+2496]
	je	$LN90@initialize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_06LOIFJNFN@?9build?$AA@
	lea	rcx, QWORD PTR [rsi+1232]
	call	QWORD PTR __imp_strstr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 99   : 		if (0!=strstr(Params,"-build"))	 flags |= CLocatorAPI::flBuildCopy;

	mov	ecx, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_07FDFMNBND@?9ebuild?$AA@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 99   : 		if (0!=strstr(Params,"-build"))	 flags |= CLocatorAPI::flBuildCopy;

	test	rax, rax
	cmovne	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rcx, QWORD PTR [rsi+1232]
	call	QWORD PTR __imp_strstr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 100  : 		if (0!=strstr(Params,"-ebuild")) flags |= CLocatorAPI::flBuildCopy|CLocatorAPI::flEBuildCopy;

	test	rax, rax
	je	SHORT $LN3@initialize
	or	ebx, 10
$LN3@initialize:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_0P@FKEDFFFF@?9file_activity?$AA@
	lea	rcx, QWORD PTR [rsi+1232]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 108  : 		flags |= CLocatorAPI::flScanAppRoot;

	bts	ebx, 7
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	call	QWORD PTR __imp_strstr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 112  : 		if (0!=strstr(Params,"-file_activity"))	 flags |= CLocatorAPI::flDumpFileActivity;

	test	rax, rax
	je	SHORT $LN2@initialize
	bts	ebx, 9
$LN2@initialize:

; 113  : 	#endif
; 114  : #endif
; 115  : 		FS._initialize		(flags,0,fs_fname);

	mov	r9, QWORD PTR fs_fname$[rsp]
	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	xor	r8d, r8d
	mov	edx, ebx
	call	?_initialize@CLocatorAPI@@QEAAXIPEBD0@Z	; CLocatorAPI::_initialize

; 116  : 		Msg					("'%s' build %d, %s\n","xrCore",build_id, build_date);

	mov	r9, QWORD PTR ?build_date@@3PEBDEB	; build_date
	mov	r8d, DWORD PTR ?build_id@@3IA		; build_id
	lea	rdx, OFFSET FLAT:??_C@_06MIBHPEBH@xrCore?$AA@
	lea	rcx, OFFSET FLAT:??_C@_0BD@JOAIEFKH@?8?$CFs?8?5build?5?$CFd?0?5?$CFs?6?$AA@
	call	?Msg@@YAXPEBDZZ				; Msg
$LN90@initialize:

; 117  : 		EFS._initialize		();
; 118  : #ifdef DEBUG
; 119  :     #ifndef	_EDITOR
; 120  : 		Msg					("CRT heap 0x%08x",_get_heap_handle());
; 121  : 		Msg					("Process heap 0x%08x",GetProcessHeap());
; 122  :     #endif
; 123  : #endif // DEBUG
; 124  : 	}
; 125  : 	
; 126  : 	SetLogCB				(cb);

	mov	rcx, r12
	call	?SetLogCB@@YAXP6AXPEBD@Z@Z		; SetLogCB

; 127  : 
; 128  : 	LPAPI_VERSION ver = ImagehlpApiVersion();

	call	QWORD PTR __imp_ImagehlpApiVersion

; 129  : 	if ( NULL == GetProcAddress ( GetModuleHandle("dbghelp.dll"), "EnumerateLoadedModulesEx") )

	lea	rcx, OFFSET FLAT:??_C@_0M@OOEJBPPK@dbghelp?4dll?$AA@
	call	QWORD PTR __imp_GetModuleHandleA
	lea	rdx, OFFSET FLAT:??_C@_0BJ@KCKDNGEA@EnumerateLoadedModulesEx?$AA@
	mov	rcx, rax
	call	QWORD PTR __imp_GetProcAddress
	mov	r12, QWORD PTR [rsp+2448]
	mov	rdi, QWORD PTR [rsp+2456]
	mov	rsi, QWORD PTR [rsp+2464]
	mov	rbx, QWORD PTR [rsp+2488]
	test	rax, rax
	jne	SHORT $LN99@initialize

; 130  : 	{
; 131  : 		string256 msg;		
; 132  : 		DWORD dwVer[2];
; 133  : 		WORD *v4 = (WORD*) &dwVer;
; 134  : 		CSymbolEngine SE;
; 135  : 		SE.GetInMemoryFileVersion("dbghelp.dll", dwVer[0], dwVer[1]);

	lea	r9, QWORD PTR dwVer$6[rsp+4]
	lea	r8, QWORD PTR dwVer$6[rsp]
	call	?GetInMemoryFileVersion@CSymbolEngine@@QEAAHPEBDAEAK1@Z ; CSymbolEngine::GetInMemoryFileVersion

; 136  : 
; 137  : 		sprintf_s(msg, 256, "  dbghelp.dll (%d.%d.%d.%d),   .", 
; 138  : 								v4[1], v4[0], v4[3], v4[2]);

	movzx	eax, WORD PTR dwVer$6[rsp+4]
	movzx	ecx, WORD PTR dwVer$6[rsp+6]
	movzx	r8d, WORD PTR dwVer$6[rsp]
	movzx	r9d, WORD PTR dwVer$6[rsp+2]
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ecx
	mov	DWORD PTR [rsp+32], r8d
	lea	r8, OFFSET FLAT:??_C@_0EG@KOOKGMKK@?S?q?r?$OA?p?e?b?x?h?i?5?t?$OA?i?k?5dbghelp?4dll?5?$CI?$CFd?4@
	lea	rcx, QWORD PTR msg$1[rsp]
	mov	edx, 256				; 00000100H
	call	QWORD PTR __imp_sprintf_s

; 139  : 		MessageBox(NULL, msg, "DebugHlp Warning", MB_OK);

	lea	r8, OFFSET FLAT:??_C@_0BB@IILKFANF@DebugHlp?5Warning?$AA@
	lea	rdx, QWORD PTR msg$1[rsp]
	xor	r9d, r9d
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
$LN99@initialize:

; 140  : 	}
; 141  : 
; 142  : 	init_counter++;

	inc	DWORD PTR init_counter

; 143  : }

	add	rsp, 2472				; 000009a8H
	ret	0
?_initialize@xrCore@@QEAAXPEBDP6AX0@ZH0@Z ENDP		; xrCore::_initialize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
;	COMDAT ?buffer@stream@ppmd@compression@@QEBAPEAEXZ
_TEXT	SEGMENT
this$dead$ = 8
?buffer@stream@ppmd@compression@@QEBAPEAEXZ PROC	; compression::ppmd::stream::buffer, COMDAT

; 36   : 	return			(m_buffer);

	mov	rax, QWORD PTR ?trained_model@@3PEAVstream@ppmd@compression@@EA ; trained_model
	mov	rax, QWORD PTR [rax+8]

; 37   : }

	ret	0
?buffer@stream@ppmd@compression@@QEBAPEAEXZ ENDP	; compression::ppmd::stream::buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
_TEXT	SEGMENT
this$ = 48
buffer$1 = 56
?_destroy@xrCore@@QEAAXXZ PROC				; xrCore::_destroy

; 150  : {

$LN18:
	sub	rsp, 40					; 00000028H

; 151  : 	--init_counter;

	dec	DWORD PTR init_counter

; 152  : 	if (0==init_counter){

	jne	$LN9@destroy

; 153  : 		FS._destroy			();

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	call	?_destroy@CLocatorAPI@@QEAAXXZ		; CLocatorAPI::_destroy

; 154  : 		EFS._destroy		();
; 155  : 		xr_delete			(xr_FS);

	call	??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z ; xr_delete<CLocatorAPI>

; 156  : 		xr_delete			(xr_EFS);

	call	??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z ; xr_delete<EFS_Utils>

; 157  : 
; 158  : #ifndef	_EDITOR
; 159  : 		if (trained_model) {

	mov	rax, QWORD PTR ?trained_model@@3PEAVstream@ppmd@compression@@EA ; trained_model
	test	rax, rax
	je	SHORT $LN1@destroy

; 160  : 			void			*buffer = trained_model->buffer();

	mov	rax, QWORD PTR [rax+8]

; 161  : 			xr_free			(buffer);

	lea	rcx, QWORD PTR buffer$1[rsp]
	mov	QWORD PTR buffer$1[rsp], rax
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>

; 162  : 			xr_delete		(trained_model);

	call	??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z ; xr_delete<compression::ppmd::stream>
$LN1@destroy:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.cpp

; 123  : 	verbosity_filters.clean();

	lea	rcx, OFFSET FLAT:?verbosity_filters@@3Vstr_container@@A ; verbosity_filters
	call	?clean@str_container@@QEAAXXZ		; str_container::clean
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 151  : 	if (ptr) 

	cmp	QWORD PTR ?g_pSharedMemoryContainer@@3PEAVsmem_container@@EA, 0 ; g_pSharedMemoryContainer
	je	SHORT $LN11@destroy

; 152  : 	{
; 153  : 		xr_special_free<xrcore::is_polymorphic<T>::result,T>()(ptr);

	call	??R?$xr_special_free@$0A@Vsmem_container@@@@QEAAXAEAPEAVsmem_container@@@Z ; xr_special_free<0,smem_container>::operator()

; 154  : 		ptr = NULL;

	mov	QWORD PTR ?g_pSharedMemoryContainer@@3PEAVsmem_container@@EA, 0 ; g_pSharedMemoryContainer
$LN11@destroy:

; 151  : 	if (ptr) 

	cmp	QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA, 0 ; g_pStringContainer
	je	SHORT $LN14@destroy

; 152  : 	{
; 153  : 		xr_special_free<xrcore::is_polymorphic<T>::result,T>()(ptr);

	call	??R?$xr_special_free@$0A@Vstr_container@@@@QEAAXAEAPEAVstr_container@@@Z ; xr_special_free<0,str_container>::operator()

; 154  : 		ptr = NULL;

	mov	QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA, 0 ; g_pStringContainer
$LN14@destroy:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.cpp

; 134  : 	mem_initialized				= FALSE;

	mov	DWORD PTR ?mem_initialized@@3HA, 0	; mem_initialized
$LN9@destroy:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp

; 168  : }

	add	rsp, 40					; 00000028H
	ret	0
?_destroy@xrCore@@QEAAXXZ ENDP				; xrCore::_destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrcore.cpp
_TEXT	SEGMENT
hinstDLL$ = 48
ul_reason_for_call$ = 56
lpvReserved$ = 64
DllMain	PROC

; 178  : {

$LN12:
	sub	rsp, 40					; 00000028H

; 179  : 	switch (ul_reason_for_call)

	dec	edx
	je	SHORT $LN4@DllMain
	dec	edx
	jne	SHORT $LN10@DllMain

; 188  : 		}
; 189  : //.		LogFile.reserve		(256);
; 190  : 		break;
; 191  : 	case DLL_THREAD_ATTACH:
; 192  : 		CoInitializeEx	(NULL, COINIT_MULTITHREADED);

	xor	ecx, ecx
	call	QWORD PTR __imp_CoInitializeEx

; 193  : 		timeBeginPeriod	(1);

	mov	ecx, 1
	call	QWORD PTR __imp_timeBeginPeriod

; 194  : 		break;
; 195  : 	case DLL_THREAD_DETACH:
; 196  : 		break;
; 197  : 	case DLL_PROCESS_DETACH:
; 198  : #ifdef USE_MEMORY_MONITOR
; 199  : 		memory_monitor::flush_each_time	(true);
; 200  : #endif // USE_MEMORY_MONITOR
; 201  : 		break;
; 202  : 	}
; 203  :     return TRUE;

	mov	eax, 1

; 204  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@DllMain:

; 180  : 	{
; 181  : 	case DLL_PROCESS_ATTACH:
; 182  : 		{
; 183  : 			_clear87		();

	call	QWORD PTR __imp__clearfp

; 184  : 			_control87		( _PC_53,   MCW_PC );

	mov	edx, 196608				; 00030000H
	mov	ecx, 65536				; 00010000H
	call	QWORD PTR __imp__control87

; 185  : 			_control87		( _RC_CHOP, MCW_RC );

	mov	edx, 768				; 00000300H
	mov	ecx, edx
	call	QWORD PTR __imp__control87

; 186  : 			_control87		( _RC_NEAR, MCW_RC );

	mov	edx, 768				; 00000300H
	xor	ecx, ecx
	call	QWORD PTR __imp__control87

; 187  : 			_control87		( _MCW_EM,  MCW_EM );

	mov	edx, 524319				; 0008001fH
	mov	ecx, edx
	call	QWORD PTR __imp__control87
$LN10@DllMain:

; 194  : 		break;
; 195  : 	case DLL_THREAD_DETACH:
; 196  : 		break;
; 197  : 	case DLL_PROCESS_DETACH:
; 198  : #ifdef USE_MEMORY_MONITOR
; 199  : 		memory_monitor::flush_each_time	(true);
; 200  : #endif // USE_MEMORY_MONITOR
; 201  : 		break;
; 202  : 	}
; 203  :     return TRUE;

	mov	eax, 1

; 204  : }

	add	rsp, 40					; 00000028H
	ret	0
DllMain	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ??$strcpy_s@$0EA@@@YAHAEAY0EA@DPEBD@Z
_TEXT	SEGMENT
_Dest$ = 8
_Source$ = 16
??$strcpy_s@$0EA@@@YAHAEAY0EA@DPEBD@Z PROC		; strcpy_s<64>, COMDAT

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	mov	r8, rdx
	mov	edx, 64					; 00000040H
	rex_jmp	QWORD PTR __imp_strcpy_s
??$strcpy_s@$0EA@@@YAHAEAY0EA@DPEBD@Z ENDP		; strcpy_s<64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VCLocatorAPI@@@@YAPEAVCLocatorAPI@@XZ
_TEXT	SEGMENT
??$xr_new@VCLocatorAPI@@@@YAPEAVCLocatorAPI@@XZ PROC	; xr_new<CLocatorAPI>, COMDAT

; 67   : {

$LN8:
	sub	rsp, 40					; 00000028H

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 128				; 00000080H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN3@xr_new
	mov	rcx, rax

; 70   : }

	add	rsp, 40					; 00000028H

; 69   : 	return new (ptr) T();

	jmp	??0CLocatorAPI@@QEAA@XZ			; CLocatorAPI::CLocatorAPI
$LN3@xr_new:

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
??$xr_new@VCLocatorAPI@@@@YAPEAVCLocatorAPI@@XZ ENDP	; xr_new<CLocatorAPI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VEFS_Utils@@@@YAPEAVEFS_Utils@@XZ
_TEXT	SEGMENT
??$xr_new@VEFS_Utils@@@@YAPEAVEFS_Utils@@XZ PROC	; xr_new<EFS_Utils>, COMDAT

; 67   : {

$LN26:
	push	rbx
	sub	rsp, 32					; 00000020H

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 24
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	rbx, rax

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN3@xr_new
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 14   : {

	lea	rax, OFFSET FLAT:??_7EFS_Utils@@6B@
	mov	QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

	mov	QWORD PTR [rbx+8], 0

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> > const ,void * __ptr64>,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > > >::_Buyheadnode
	mov	QWORD PTR [rbx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	rax, rbx

; 70   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@xr_new:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$xr_new@VEFS_Utils@@@@YAPEAVEFS_Utils@@XZ ENDP	; xr_new<EFS_Utils>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z
_TEXT	SEGMENT
ptr$dead$ = 48
??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z PROC ; xr_delete<CLocatorAPI>, COMDAT

; 150  : {

$LN37:
	sub	rsp, 40					; 00000028H

; 151  : 	if (ptr) 

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	test	rcx, rcx
	je	SHORT $LN1@xr_delete
	mov	QWORD PTR [rsp+32], rdi
	call	??1CLocatorAPI@@QEAA@XZ			; CLocatorAPI::~CLocatorAPI
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	rdi, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN13@xr_delete
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN34@xr_delete

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 157  : 	} else {

	jmp	SHORT $LN34@xr_delete
$LN13@xr_delete:

; 158  : 		// pooled
; 159  : 		VERIFY2					(pool<mem_pools_count,"Memory corruption");
; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
$LN34@xr_delete:
	mov	rdi, QWORD PTR [rsp+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 154  : 		ptr = NULL;

	mov	QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA, 0 ; xr_FS
$LN1@xr_delete:

; 155  : 	}
; 156  : }

	add	rsp, 40					; 00000028H
	ret	0
??$xr_delete@VCLocatorAPI@@@@YAXAEAPEAVCLocatorAPI@@@Z ENDP ; xr_delete<CLocatorAPI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z
_TEXT	SEGMENT
ptr$dead$ = 48
??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z PROC	; xr_delete<EFS_Utils>, COMDAT

; 150  : {

$LN32:
	sub	rsp, 40					; 00000028H

; 151  : 	if (ptr) 

	mov	rcx, QWORD PTR ?xr_EFS@@3PEAVEFS_Utils@@EA ; xr_EFS
	test	rcx, rcx
	je	$LN1@xr_delete
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+32], rdi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	mov	rcx, QWORD PTR ?xr_EFS@@3PEAVEFS_Utils@@EA ; xr_EFS
	xor	edx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rdi, QWORD PTR [rax-1]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 133  : 		ptr->~T			();

	mov	r8, QWORD PTR [rcx]
	call	QWORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi]

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN8@xr_delete
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN29@xr_delete

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 157  : 	} else {

	jmp	SHORT $LN29@xr_delete
$LN8@xr_delete:

; 158  : 		// pooled
; 159  : 		VERIFY2					(pool<mem_pools_count,"Memory corruption");
; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN29@xr_delete:
	mov	rdi, QWORD PTR [rsp+32]
	mov	rbx, QWORD PTR [rsp+48]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 154  : 		ptr = NULL;

	mov	QWORD PTR ?xr_EFS@@3PEAVEFS_Utils@@EA, 0 ; xr_EFS
$LN1@xr_delete:

; 155  : 	}
; 156  : }

	add	rsp, 40					; 00000028H
	ret	0
??$xr_delete@VEFS_Utils@@@@YAXAEAPEAVEFS_Utils@@@Z ENDP	; xr_delete<EFS_Utils>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z
_TEXT	SEGMENT
ptr$dead$ = 48
??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z PROC ; xr_delete<compression::ppmd::stream>, COMDAT

; 150  : {

$LN32:
	push	rdi
	sub	rsp, 32					; 00000020H

; 151  : 	if (ptr) 

	mov	rdi, QWORD PTR ?trained_model@@3PEAVstream@ppmd@compression@@EA ; trained_model
	test	rdi, rdi
	je	SHORT $LN1@xr_delete
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN8@xr_delete
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN29@xr_delete

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 154  : 		ptr = NULL;

	mov	QWORD PTR ?trained_model@@3PEAVstream@ppmd@compression@@EA, 0 ; trained_model

; 155  : 	}
; 156  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@xr_delete:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
$LN29@xr_delete:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 154  : 		ptr = NULL;

	mov	QWORD PTR ?trained_model@@3PEAVstream@ppmd@compression@@EA, 0 ; trained_model
$LN1@xr_delete:

; 155  : 	}
; 156  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$xr_delete@Vstream@ppmd@compression@@@@YAXAEAPEAVstream@ppmd@compression@@@Z ENDP ; xr_delete<compression::ppmd::stream>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z
_TEXT	SEGMENT
this$dead$ = 48
ptr$dead$ = 56
??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z PROC ; xr_special_free<0,CLocatorAPI>::operator(), COMDAT

; 142  : 	{

$LN34:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	call	??1CLocatorAPI@@QEAA@XZ			; CLocatorAPI::~CLocatorAPI
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	rdi, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN10@operator
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN31@operator

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 145  : 	}

	add	rsp, 32					; 00000020H
	pop	rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 303  : 	free((void *)ptr);

	rex_jmp	QWORD PTR __imp_free
$LN10@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
$LN31@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 145  : 	}

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R?$xr_special_free@$0A@VCLocatorAPI@@@@QEAAXAEAPEAVCLocatorAPI@@@Z ENDP ; xr_special_free<0,CLocatorAPI>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VEFS_Utils@@@@QEAAXAEAPEAVEFS_Utils@@@Z
_TEXT	SEGMENT
this$dead$ = 48
ptr$dead$ = 56
??R?$xr_special_free@$00VEFS_Utils@@@@QEAAXAEAPEAVEFS_Utils@@@Z PROC ; xr_special_free<1,EFS_Utils>::operator(), COMDAT

; 131  : 	{

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	rcx, QWORD PTR ?xr_EFS@@3PEAVEFS_Utils@@EA ; xr_EFS
	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	mov	rcx, QWORD PTR ?xr_EFS@@3PEAVEFS_Utils@@EA ; xr_EFS
	xor	edx, edx
	mov	r8, QWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rdi, QWORD PTR [rax-1]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 133  : 		ptr->~T			();

	call	QWORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi]

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN5@operator
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN26@operator

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 135  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 303  : 	free((void *)ptr);

	rex_jmp	QWORD PTR __imp_free
$LN5@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN26@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 135  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R?$xr_special_free@$00VEFS_Utils@@@@QEAAXAEAPEAVEFS_Utils@@@Z ENDP ; xr_special_free<1,EFS_Utils>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z
_TEXT	SEGMENT
this$dead$ = 48
ptr$dead$ = 56
??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z PROC ; xr_special_free<0,compression::ppmd::stream>::operator(), COMDAT

; 142  : 	{

$LN29:
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	rdi, QWORD PTR ?trained_model@@3PEAVstream@ppmd@compression@@EA ; trained_model
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN5@operator
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN26@operator

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 145  : 	}

	add	rsp, 32					; 00000020H
	pop	rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 303  : 	free((void *)ptr);

	rex_jmp	QWORD PTR __imp_free
$LN5@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
$LN26@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 145  : 	}

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R?$xr_special_free@$0A@Vstream@ppmd@compression@@@@QEAAXAEAPEAVstream@ppmd@compression@@@Z ENDP ; xr_special_free<0,compression::ppmd::stream>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GCLocatorAPI@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GCLocatorAPI@@QEAAPEAXI@Z PROC			; CLocatorAPI::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1CLocatorAPI@@QEAA@XZ			; CLocatorAPI::~CLocatorAPI
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GCLocatorAPI@@QEAAPEAXI@Z ENDP			; CLocatorAPI::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ?strstr@@YAPEADPEADPEBD@Z
_TEXT	SEGMENT
_Str$ = 8
_SubStr$ = 16
?strstr@@YAPEADPEADPEBD@Z PROC				; strstr, COMDAT

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	rex_jmp	QWORD PTR __imp_strstr
?strstr@@YAPEADPEADPEBD@Z ENDP				; strstr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ?strconcat@@YAPEBDHPEADPEBD1@Z
_TEXT	SEGMENT
dest_sz$ = 48
dest$ = 56
S1$ = 64
S2$ = 72
?strconcat@@YAPEBDHPEADPEBD1@Z PROC			; strconcat, COMDAT

; 171  : {

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbp, r9
	mov	rsi, rdx
	movsxd	rdi, ecx

; 178  : 
; 179  : // dest = S1+S2+S3
; 180  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3)
; 181  : {
; 182  : 	u32 l1 = xr_strlen(S1);
; 183  : 	u32 l2 = xr_strlen(S2);
; 184  : 	strcpy_s(dest,dest_sz,S1);
; 185  : 	strcat_s(dest,dest_sz-l1,S2);
; 186  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 187  : 
; 188  : 	return dest;
; 189  : //.	return strcat(strcat(strcpy(dest,S1),S2),S3);
; 190  : }
; 191  : 
; 192  : // dest = S1+S2+S3+S4
; 193  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4)
; 194  : {
; 195  : 	u32 l1 = xr_strlen(S1);
; 196  : 	u32 l2 = xr_strlen(S2);
; 197  : 	u32 l3 = xr_strlen(S3);
; 198  : 	strcpy_s(dest,dest_sz,S1);
; 199  : 	strcat_s(dest,dest_sz-l1,S2);
; 200  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 201  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 202  : 
; 203  : 	return dest;
; 204  : //.	return strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4);
; 205  : }
; 206  : 
; 207  : // dest = S1+S2+S3+S4+S5
; 208  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 209  : {
; 210  : 	u32 l1 = xr_strlen(S1);
; 211  : 	u32 l2 = xr_strlen(S2);
; 212  : 	u32 l3 = xr_strlen(S3);
; 213  : 	u32 l4 = xr_strlen(S4);
; 214  : 	strcpy_s(dest,dest_sz,S1);
; 215  : 	strcat_s(dest,dest_sz-l1,S2);
; 216  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 217  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 218  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 219  : 
; 220  : 	return dest;
; 221  : //.	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5);
; 222  : }
; 223  : 
; 224  : // dest = S1+S2+S3+S4+S5+S6
; 225  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 226  : {
; 227  : 	u32 l1 = xr_strlen(S1);
; 228  : 	u32 l2 = xr_strlen(S2);
; 229  : 	u32 l3 = xr_strlen(S3);
; 230  : 	u32 l4 = xr_strlen(S4);
; 231  : 	u32 l5 = xr_strlen(S5);
; 232  : 	strcpy_s(dest,dest_sz,S1);
; 233  : 	strcat_s(dest,dest_sz-l1,S2);
; 234  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 235  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 236  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 237  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4-l5,S6);
; 238  : 
; 239  : 	return dest;
; 240  : 	//.	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6);
; 241  : }
; 242  : 
; 243  : #else
; 244  : 
; 245  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2)
; 246  : {	return strcat(strcpy(dest,S1),S2); }
; 247  : 
; 248  : // dest = S1+S2+S3
; 249  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3)
; 250  : {	return strcat(strcat(strcpy(dest,S1),S2),S3); }
; 251  : 
; 252  : // dest = S1+S2+S3+S4
; 253  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4)
; 254  : {	return strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4); }
; 255  : 
; 256  : // dest = S1+S2+S3+S4+S5
; 257  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 258  : {	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5); }
; 259  : 
; 260  : // dest = S1+S2+S3+S4+S5+S6
; 261  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 262  : {	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6); }
; 263  : 
; 264  : #endif
; 265  : // return pointer to ".ext"
; 266  : IC char*						strext					( const char* S )
; 267  : {	return (char*) strrchr(S,'.');	}
; 268  : 
; 269  : IC u32							xr_strlen				( const char* S )
; 270  : {	return (u32)strlen(S);			}

	or	rbx, -1
$LL5@strconcat:
	inc	rbx
	cmp	BYTE PTR [r8+rbx], 0
	jne	SHORT $LL5@strconcat

; 172  : 	u32 l1 = xr_strlen(S1);
; 173  : 	strcpy_s(dest,dest_sz,S1);

	mov	rdx, rdi
	mov	rcx, rsi
	call	QWORD PTR __imp_strcpy_s

; 174  : 	strcat_s(dest,dest_sz-l1,S2);

	sub	edi, ebx
	mov	r8, rbp
	mov	edx, edi
	mov	rcx, rsi
	call	QWORD PTR __imp_strcat_s

; 175  : 	return dest;
; 176  : //.	return strcat(strcpy(dest,S1),S2);
; 177  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?strconcat@@YAPEBDHPEADPEBD1@Z ENDP			; strconcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??_U@YAPEAX_K@Z
_TEXT	SEGMENT
size$ = 8
??_U@YAPEAX_K@Z PROC					; operator new[], COMDAT

; 128  : 	IC void*	operator new[]		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	test	rcx, rcx
	mov	edx, 1
	cmovne	rdx, rcx
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	jmp	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
??_U@YAPEAX_K@Z ENDP					; operator new[]
_TEXT	ENDS
END
