; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CG@DOMCHCAE@?$FL?$CF02d?4?$CF02d?4?$CF02d?5?$CF02d?3?$CF02d?3?$CF02d?4?$CF@ ; `string'
PUBLIC	??_C@_06PADMJNAK@?$CFs?$CFs?$AN?6?$AA@		; `string'
PUBLIC	??_C@_09PMCACMHN@?$CDCONTEXT?3?$AA@		; `string'
PUBLIC	??_C@_0BK@EDFKPBBE@?$FL?$CF02d?3?$CF02d?3?$CF02d?4?$CF03d?$FN?4?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0O@LCKMNMMD@?$CDDUMP_CONTEXT?$AA@		; `string'
PUBLIC	??_C@_0BF@FNJBEDFL@?$CDDEBUG?5CONTEXT?5DUMP?3?$AA@ ; `string'
PUBLIC	??_C@_04CFBKFMDG@?$CD?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_05KDNLHNC@?$CFs?5?$CFf?$AA@		; `string'
PUBLIC	??_C@_0O@LEOODNAC@?$CFs?5?$CI?$CFf?0?$CFf?0?$CFf?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0DF@PAGJPMKE@?$CFs?3?6?$CFf?0?$CFf?0?$CFf?0?$CFf?6?$CFf?0?$CFf?0?$CFf?0?$CFf?6?$CFf?0?$CF@ ; `string'
PUBLIC	??_C@_06DJHOIPC@?$CFs?3?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_07OMNKEAIN@InitLog?$AA@			; `string'
PUBLIC	??_C@_07FJDKEOKC@log?4cpp?$AA@			; `string'
PUBLIC	??_C@_0O@EOBOPHIF@LogFile?$DN?$DNNULL?$AA@	; `string'
PUBLIC	??_C@_04FPOLKAEB@?4log?$AA@			; `string'
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
PUBLIC	??_C@_0BH@FLDDKOBP@Can?8t?5create?5log?5file?4?$AA@ ; `string'
PUBLIC	??_C@_08DCHCECCB@?$FL?$CFx?5?$CFX?$FN?7?$AA@	; `string'
PUBLIC	??_C@_05JMJKDBEJ@?$CFs?$CFs?6?$AA@		; `string'
PUBLIC	?cached_log@@3_KA				; cached_log
PUBLIC	?LogWriter@@3PEAVIWriter@@EA			; LogWriter
PUBLIC	?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA ; LogFile
PUBLIC	?force_flush_log@@3_NA				; force_flush_log
PUBLIC	?verbosity_level@@3IA				; verbosity_level
PUBLIC	?LogExecCB@@3HA					; LogExecCB
EXTRN	__imp_strftime:PROC
EXTRN	__imp__localtime64:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp__vsnprintf:PROC
EXTRN	__imp_GetLocalTime:PROC
EXTRN	__imp_strtok:PROC
;	COMDAT ?ignore_always@?3??InitLog@@YAXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?3??InitLog@@YAXXZ@4_NA DB 01H DUP (?)	; `InitLog'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ctx_index@?1??MsgCB@@YAXPEBDZZ@4IA
_BSS	SEGMENT
?ctx_index@?1??MsgCB@@YAXPEBDZZ@4IA DD 01H DUP (?)	; `MsgCB'::`2'::ctx_index
?cached_log@@3_KA DQ 01H DUP (?)			; cached_log
?LogWriter@@3PEAVIWriter@@EA DQ 01H DUP (?)		; LogWriter
LogCB	DQ	01H DUP (?)
?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA DQ 01H DUP (?) ; LogFile
?force_flush_log@@3_NA DB 01H DUP (?)			; force_flush_log
_BSS	ENDS
;	COMDAT ??_C@_05JMJKDBEJ@?$CFs?$CFs?6?$AA@
CONST	SEGMENT
??_C@_05JMJKDBEJ@?$CFs?$CFs?6?$AA@ DB '%s%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DCHCECCB@?$FL?$CFx?5?$CFX?$FN?7?$AA@
CONST	SEGMENT
??_C@_08DCHCECCB@?$FL?$CFx?5?$CFX?$FN?7?$AA@ DB '[%x %X]', 09H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FLDDKOBP@Can?8t?5create?5log?5file?4?$AA@
CONST	SEGMENT
??_C@_0BH@FLDDKOBP@Can?8t?5create?5log?5file?4?$AA@ DB 'Can''t create log'
	DB	' file.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FPOLKAEB@?4log?$AA@
CONST	SEGMENT
??_C@_04FPOLKAEB@?4log?$AA@ DB '.log', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EOBOPHIF@LogFile?$DN?$DNNULL?$AA@
CONST	SEGMENT
??_C@_0O@EOBOPHIF@LogFile?$DN?$DNNULL?$AA@ DB 'LogFile==NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FJDKEOKC@log?4cpp?$AA@
CONST	SEGMENT
??_C@_07FJDKEOKC@log?4cpp?$AA@ DB 'log.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OMNKEAIN@InitLog?$AA@
CONST	SEGMENT
??_C@_07OMNKEAIN@InitLog?$AA@ DB 'InitLog', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DJHOIPC@?$CFs?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_06DJHOIPC@?$CFs?3?5?$CFs?$AA@ DB '%s: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PAGJPMKE@?$CFs?3?6?$CFf?0?$CFf?0?$CFf?0?$CFf?6?$CFf?0?$CFf?0?$CFf?0?$CFf?6?$CFf?0?$CF@
CONST	SEGMENT
??_C@_0DF@PAGJPMKE@?$CFs?3?6?$CFf?0?$CFf?0?$CFf?0?$CFf?6?$CFf?0?$CFf?0?$CFf?0?$CFf?6?$CFf?0?$CF@ DB '%'
	DB	's:', 0aH, '%f,%f,%f,%f', 0aH, '%f,%f,%f,%f', 0aH, '%f,%f,%f,%'
	DB	'f', 0aH, '%f,%f,%f,%f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LEOODNAC@?$CFs?5?$CI?$CFf?0?$CFf?0?$CFf?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@LEOODNAC@?$CFs?5?$CI?$CFf?0?$CFf?0?$CFf?$CJ?$AA@ DB '%s (%f,%f,%'
	DB	'f)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDNLHNC@?$CFs?5?$CFf?$AA@
CONST	SEGMENT
??_C@_05KDNLHNC@?$CFs?5?$CFf?$AA@ DB '%s %f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@ DB '%s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@ DB '%s %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CFBKFMDG@?$CD?5?$CFs?$AA@
CONST	SEGMENT
??_C@_04CFBKFMDG@?$CD?5?$CFs?$AA@ DB '# %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FNJBEDFL@?$CDDEBUG?5CONTEXT?5DUMP?3?$AA@
CONST	SEGMENT
??_C@_0BF@FNJBEDFL@?$CDDEBUG?5CONTEXT?5DUMP?3?$AA@ DB '#DEBUG CONTEXT DUM'
	DB	'P:', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LCKMNMMD@?$CDDUMP_CONTEXT?$AA@
CONST	SEGMENT
??_C@_0O@LCKMNMMD@?$CDDUMP_CONTEXT?$AA@ DB '#DUMP_CONTEXT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EDFKPBBE@?$FL?$CF02d?3?$CF02d?3?$CF02d?4?$CF03d?$FN?4?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BK@EDFKPBBE@?$FL?$CF02d?3?$CF02d?3?$CF02d?4?$CF03d?$FN?4?5?$CFs?$AA@ DB '['
	DB	'%02d:%02d:%02d.%03d]. %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PMCACMHN@?$CDCONTEXT?3?$AA@
CONST	SEGMENT
??_C@_09PMCACMHN@?$CDCONTEXT?3?$AA@ DB '#CONTEXT:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PADMJNAK@?$CFs?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_06PADMJNAK@?$CFs?$CFs?$AN?6?$AA@ DB '%s%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DOMCHCAE@?$FL?$CF02d?4?$CF02d?4?$CF02d?5?$CF02d?3?$CF02d?3?$CF02d?4?$CF@
CONST	SEGMENT
??_C@_0CG@DOMCHCAE@?$FL?$CF02d?4?$CF02d?4?$CF02d?5?$CF02d?3?$CF02d?3?$CF02d?4?$CF@ DB '['
	DB	'%02d.%02d.%02d %02d:%02d:%02d.%03d] ', 00H	; `string'
?verbosity_level@@3IA DD 03H				; verbosity_level
no_log	DD	01H
?LogExecCB@@3HA DD 01H					; LogExecCB
logFName DB	'engine.log', 00H
	ORG $+509
PUBLIC	??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEBV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z ; std::_Alloc_construct::_Fn<xalloc<shared_str>,shared_str,shared_str const & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z ; std::_Alloc_construct::_Fn<xalloc<shared_str>,shared_str,shared_str & __ptr64>
PUBLIC	??$construct@Vshared_str@@AEBV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z ; std::allocator_traits<xalloc<shared_str> >::construct<shared_str,shared_str const & __ptr64>
PUBLIC	??$construct@Vshared_str@@AEAV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z ; std::allocator_traits<xalloc<shared_str> >::construct<shared_str,shared_str & __ptr64>
PUBLIC	??$forward@AEAVshared_str@@@std@@YAAEAVshared_str@@AEAV1@@Z ; std::forward<shared_str & __ptr64>
PUBLIC	??_G?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAPEAXI@Z ; xr_vector<shared_str,xalloc<shared_str> >::`scalar deleting destructor'
PUBLIC	??R?$xr_special_free@$0A@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@QEAAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z ; xr_special_free<0,xr_vector<shared_str,xalloc<shared_str> > >::operator()
PUBLIC	??$construct@Vshared_str@@AEBV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEBV2@@Z ; std::_Wrap_alloc<xalloc<shared_str> >::construct<shared_str,shared_str const & __ptr64>
PUBLIC	??$construct@Vshared_str@@AEAV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEAV2@@Z ; std::_Wrap_alloc<xalloc<shared_str> >::construct<shared_str,shared_str & __ptr64>
PUBLIC	??$addressof@$$CBVshared_str@@@std@@YAPEBVshared_str@@AEBV1@@Z ; std::addressof<shared_str const >
PUBLIC	??$xr_delete@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z ; xr_delete<xr_vector<shared_str,xalloc<shared_str> > >
PUBLIC	??$xr_new@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@XZ ; xr_new<xr_vector<shared_str,xalloc<shared_str> > >
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAA@PEAVshared_str@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator+
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBAAEAVshared_str@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator*
PUBLIC	?begin@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@2@XZ ; std::vector<shared_str,xalloc<shared_str> >::begin
PUBLIC	?push_back@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAXAEBVshared_str@@@Z ; std::vector<shared_str,xalloc<shared_str> >::push_back
PUBLIC	?reserve@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAX_K@Z ; std::vector<shared_str,xalloc<shared_str> >::reserve
PUBLIC	??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAAEAVshared_str@@_K@Z ; xr_vector<shared_str,xalloc<shared_str> >::operator[]
PUBLIC	?GetLogCB@@YAP6AXPEBD@ZXZ			; GetLogCB
PUBLIC	?LogXrayOffset@@YAXPEBDPEAX1@Z			; LogXrayOffset
PUBLIC	?LogWinErr@@YAXPEBDJ@Z				; LogWinErr
PUBLIC	?Log@@YAXPEBDAEBU?$_matrix@M@@@Z		; Log
PUBLIC	?Log@@YAXPEBDAEBU?$_vector3@M@@@Z		; Log
PUBLIC	?Log@@YAXPEBDM@Z				; Log
PUBLIC	?Log@@YAXPEBDH@Z				; Log
PUBLIC	?MsgV@@YAXPEBD0ZZ				; MsgV
PUBLIC	?MsgCB@@YAXPEBDZZ				; MsgCB
PUBLIC	?LogVAList@@YAXPEBDAEAPEAD@Z			; LogVAList
PUBLIC	?AddOne@@YAXPEBD@Z				; AddOne
PUBLIC	?InitVerbosity@@YAXPEBD@Z			; InitVerbosity
PUBLIC	?FlushLog@@YAXXZ				; FlushLog
PUBLIC	?FlushLog@@YAXPEBD@Z				; FlushLog
PUBLIC	?Log@@YAXPEBD0@Z				; Log
PUBLIC	?Log@@YAXPEBDI@Z				; Log
PUBLIC	?CreateLog@@YAXH@Z				; CreateLog
PUBLIC	?CloseLog@@YAXXZ				; CloseLog
PUBLIC	?Log@@YAXPEBD@Z					; Log
PUBLIC	?InitLog@@YAXXZ					; InitLog
PUBLIC	?SetLogCB@@YAXP6AXPEBD@Z@Z			; SetLogCB
PUBLIC	?Msg@@YAXPEBDZZ					; Msg
PUBLIC	?verbosity_filters@@3Vstr_container@@A		; verbosity_filters
	ALIGN	4

?verbosity_filters@@3Vstr_container@@A DB 018H DUP (?)	; verbosity_filters
	ALIGN	8

logCS	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ?ctx_ring@?1??MsgCB@@YAXPEBDZZ@4PAY0BAAA@DA
_BSS	SEGMENT
?ctx_ring@?1??MsgCB@@YAXPEBDZZ@4PAY0BAAA@DA DB 010000H DUP (?) ; `MsgCB'::`2'::ctx_ring
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEBV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z DD imagerel $LN24
	DD	imagerel $LN24+56
	DD	imagerel $unwind$??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEBV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z DD imagerel $LN24
	DD	imagerel $LN24+48
	DD	imagerel $unwind$??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@Vshared_str@@AEBV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z DD imagerel $LN28
	DD	imagerel $LN28+67
	DD	imagerel $unwind$??$construct@Vshared_str@@AEBV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@Vshared_str@@AEAV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z DD imagerel $LN28
	DD	imagerel $LN28+44
	DD	imagerel $unwind$??$construct@Vshared_str@@AEAV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAPEAXI@Z DD imagerel $LN13
	DD	imagerel $LN13+54
	DD	imagerel $unwind$??_G?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$xr_special_free@$0A@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@QEAAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z DD imagerel $LN15
	DD	imagerel $LN15+81
	DD	imagerel $unwind$??R?$xr_special_free@$0A@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@QEAAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@Vshared_str@@AEBV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEBV2@@Z DD imagerel $LN32
	DD	imagerel $LN32+82
	DD	imagerel $unwind$??$construct@Vshared_str@@AEBV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEBV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@Vshared_str@@AEAV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEAV2@@Z DD imagerel $LN32
	DD	imagerel $LN32+44
	DD	imagerel $unwind$??$construct@Vshared_str@@AEAV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_delete@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z DD imagerel $LN18
	DD	imagerel $LN18+71
	DD	imagerel $unwind$??$xr_delete@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@XZ DD imagerel $LN17
	DD	imagerel $LN17+90
	DD	imagerel $unwind$??$xr_new@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAAAEAV01@_J@Z DD imagerel $LN5
	DD	imagerel $LN5+39
	DD	imagerel $unwind$??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAA@PEAVshared_str@@PEBU_Container_base0@1@@Z DD imagerel $LN7
	DD	imagerel $LN7+49
	DD	imagerel $unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAA@PEAVshared_str@@PEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBA?AV01@_J@Z DD imagerel $LN7
	DD	imagerel $LN7+70
	DD	imagerel $unwind$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBA?AV01@_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBAAEAVshared_str@@XZ DD imagerel $LN5
	DD	imagerel $LN5+24
	DD	imagerel $unwind$??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBAAEAVshared_str@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@2@XZ DD imagerel $LN9
	DD	imagerel $LN9+57
	DD	imagerel $unwind$?begin@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAXAEBVshared_str@@@Z DD imagerel $LN151
	DD	imagerel $LN151+358
	DD	imagerel $unwind$?push_back@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAXAEBVshared_str@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAX_K@Z DD imagerel $LN27
	DD	imagerel $LN27+78
	DD	imagerel $unwind$?reserve@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAAEAVshared_str@@_K@Z DD imagerel $LN24
	DD	imagerel $LN24+103
	DD	imagerel $unwind$??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAAEAVshared_str@@_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?LogWinErr@@YAXPEBDJ@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?LogWinErr@@YAXPEBDJ@Z
$pdata$?Log@@YAXPEBDAEBU?$_matrix@M@@@Z DD imagerel $LN3
	DD	imagerel $LN3+579
	DD	imagerel $unwind$?Log@@YAXPEBDAEBU?$_matrix@M@@@Z
$pdata$?Log@@YAXPEBDAEBU?$_vector3@M@@@Z DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$?Log@@YAXPEBDAEBU?$_vector3@M@@@Z
$pdata$?Log@@YAXPEBDM@Z DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?Log@@YAXPEBDM@Z
$pdata$?Log@@YAXPEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?Log@@YAXPEBDH@Z
$pdata$?MsgV@@YAXPEBD0ZZ DD imagerel $LN12
	DD	imagerel $LN12+297
	DD	imagerel $unwind$?MsgV@@YAXPEBD0ZZ
$pdata$?MsgCB@@YAXPEBDZZ DD imagerel $LN13
	DD	imagerel $LN13+421
	DD	imagerel $unwind$?MsgCB@@YAXPEBDZZ
$pdata$?LogVAList@@YAXPEBDAEAPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+119
	DD	imagerel $unwind$?LogVAList@@YAXPEBDAEAPEAD@Z
$pdata$?AddOne@@YAXPEBD@Z DD imagerel $LN31
	DD	imagerel $LN31+488
	DD	imagerel $unwind$?AddOne@@YAXPEBD@Z
$pdata$?InitVerbosity@@YAXPEBD@Z DD imagerel $LN8
	DD	imagerel $LN8+172
	DD	imagerel $unwind$?InitVerbosity@@YAXPEBD@Z
$pdata$?FlushLog@@YAXXZ DD imagerel $LN8
	DD	imagerel $LN8+38
	DD	imagerel $unwind$?FlushLog@@YAXXZ
$pdata$?FlushLog@@YAXPEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+38
	DD	imagerel $unwind$?FlushLog@@YAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FlogCS@@YAXXZ DD imagerel ??__FlogCS@@YAXXZ
	DD	imagerel ??__FlogCS@@YAXXZ+33
	DD	imagerel $unwind$??__FlogCS@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__ElogCS@@YAXXZ DD imagerel ??__ElogCS@@YAXXZ
	DD	imagerel ??__ElogCS@@YAXXZ+53
	DD	imagerel $unwind$??__ElogCS@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fverbosity_filters@@YAXXZ DD imagerel ??__Fverbosity_filters@@YAXXZ
	DD	imagerel ??__Fverbosity_filters@@YAXXZ+155
	DD	imagerel $unwind$??__Fverbosity_filters@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Everbosity_filters@@YAXXZ DD imagerel ??__Everbosity_filters@@YAXXZ
	DD	imagerel ??__Everbosity_filters@@YAXXZ+81
	DD	imagerel $unwind$??__Everbosity_filters@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Log@@YAXPEBD0@Z DD imagerel $LN5
	DD	imagerel $LN5+123
	DD	imagerel $unwind$?Log@@YAXPEBD0@Z
$pdata$?Log@@YAXPEBDI@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?Log@@YAXPEBDI@Z
$pdata$?CreateLog@@YAXH@Z DD imagerel $LN82
	DD	imagerel $LN82+453
	DD	imagerel $unwind$?CreateLog@@YAXH@Z
$pdata$?CloseLog@@YAXXZ DD imagerel $LN70
	DD	imagerel $LN70+67
	DD	imagerel $unwind$?CloseLog@@YAXXZ
$pdata$?Log@@YAXPEBD@Z DD imagerel $LN9
	DD	imagerel $LN9+231
	DD	imagerel $unwind$?Log@@YAXPEBD@Z
$pdata$?InitLog@@YAXXZ DD imagerel $LN23
	DD	imagerel $LN23+104
	DD	imagerel $unwind$?InitLog@@YAXXZ
$pdata$?Msg@@YAXPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?Msg@@YAXPEBDZZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Everbosity_filters@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fverbosity_filters@@YAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__ElogCS@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FlogCS@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
xdata	SEGMENT
$unwind$?LogWinErr@@YAXPEBDJ@Z DD 010d01H
	DD	0420dH
$unwind$?Log@@YAXPEBDAEBU?$_matrix@M@@@Z DD 0166901H
	DD	04af869H
	DD	04be860H
	DD	04cd857H
	DD	04dc84eH
	DD	04eb845H
	DD	04fa83cH
	DD	0509833H
	DD	051882aH
	DD	0527821H
	DD	0536819H
	DD	0a90111H
$unwind$?Log@@YAXPEBDAEBU?$_vector3@M@@@Z DD 021101H
	DD	0890111H
$unwind$?Log@@YAXPEBDM@Z DD 021201H
	DD	0870112H
$unwind$?Log@@YAXPEBDH@Z DD 021001H
	DD	0870110H
$unwind$?MsgV@@YAXPEBD0ZZ DD 011801H
	DD	08218H
$unwind$?MsgCB@@YAXPEBDZZ DD 022101H
	DD	020f0121H
$unwind$?LogVAList@@YAXPEBDAEAPEAD@Z DD 021701H
	DD	02070117H
$unwind$?AddOne@@YAXPEBD@Z DD 020c01H
	DD	019010cH
$unwind$?InitVerbosity@@YAXPEBD@Z DD 021201H
	DD	02070112H
$unwind$?FlushLog@@YAXXZ DD 010401H
	DD	04204H
$unwind$?FlushLog@@YAXPEBD@Z DD 010401H
	DD	04204H
$unwind$?Log@@YAXPEBD0@Z DD 021101H
	DD	0870111H
$unwind$?Log@@YAXPEBDI@Z DD 021001H
	DD	0870110H
$unwind$?CreateLog@@YAXH@Z DD 020b01H
	DD	015010bH
$unwind$?CloseLog@@YAXXZ DD 010401H
	DD	04204H
$unwind$?Log@@YAXPEBD@Z DD 020c01H
	DD	087010cH
$unwind$?InitLog@@YAXXZ DD 010401H
	DD	06204H
$unwind$?Msg@@YAXPEBDZZ DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAAEAVshared_str@@_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAXAEBVshared_str@@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBAAEAVshared_str@@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBA?AV01@_J@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAA@PEAVshared_str@@PEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAAAEAV01@_J@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@XZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_delete@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@Vshared_str@@AEAV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEAV2@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@Vshared_str@@AEBV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEBV2@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$xr_special_free@$0A@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@QEAAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@Vshared_str@@AEAV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@Vshared_str@@AEBV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z DD 011701H
	DD	04217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEBV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z DD 011701H
	DD	04217H
verbosity_filters$initializer$ DQ FLAT:??__Everbosity_filters@@YAXXZ
logCS$initializer$ DQ FLAT:??__ElogCS@@YAXXZ
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
mark$ = 32
format$ = 64
?Msg@@YAXPEBDZZ PROC					; Msg

; 154  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 155  : 	va_list mark;	
; 156  : 	va_start	(mark, format );

	lea	rax, QWORD PTR format$[rsp+8]
	mov	QWORD PTR mark$[rsp], rax

; 157  : 	LogVAList   (format, mark);

	lea	rdx, QWORD PTR mark$[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	?LogVAList@@YAXPEBDAEAPEAD@Z		; LogVAList

; 158  : }

	add	rsp, 56					; 00000038H
	ret	0
?Msg@@YAXPEBDZZ ENDP					; Msg
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
cb$ = 8
?SetLogCB@@YAXP6AXPEBD@Z@Z PROC				; SetLogCB

; 288  : {

	mov	QWORD PTR [rsp+8], rcx

; 289  : 	LogCB				= cb;

	mov	rax, QWORD PTR cb$[rsp]
	mov	QWORD PTR LogCB, rax

; 290  : }

	ret	0
?SetLogCB@@YAXP6AXPEBD@Z@Z ENDP				; SetLogCB
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
?InitLog@@YAXXZ PROC					; InitLog

; 304  : {

$LN23:
	sub	rsp, 56					; 00000038H
$LN4@InitLog:

; 305  : 	R_ASSERT			(LogFile==NULL);

	movzx	eax, BYTE PTR ?ignore_always@?3??InitLog@@YAXXZ@4_NA
	test	eax, eax
	jne	SHORT $LN1@InitLog
	cmp	QWORD PTR ?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA, 0 ; LogFile
	je	SHORT $LN1@InitLog
	lea	rax, OFFSET FLAT:?ignore_always@?3??InitLog@@YAXXZ@4_NA
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_07OMNKEAIN@InitLog?$AA@
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 305				; 00000131H
	lea	r8, OFFSET FLAT:??_C@_07FJDKEOKC@log?4cpp?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0O@EOBOPHIF@LogFile?$DN?$DNNULL?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	call	?fail@xrDebug@@QEAAXPEBD0H0AEA_N@Z	; xrDebug::fail
$LN1@InitLog:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@InitLog

; 306  : 	LogFile				= xr_new< xr_vector<shared_str> >();

	call	??$xr_new@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@XZ ; xr_new<xr_vector<shared_str,xalloc<shared_str> > >
	mov	QWORD PTR ?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA, rax ; LogFile

; 307  : }

	add	rsp, 56					; 00000038H
	ret	0
?InitLog@@YAXXZ ENDP					; InitLog
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
j$ = 32
i$ = 36
split$ = 48
s$ = 1088
?Log@@YAXPEBD@Z PROC					; Log

; 126  : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1080				; 00000438H

; 127  : 	int		i,j;
; 128  : 	char	split[1024];
; 129  : 
; 130  : 	for (i=0,j=0; s[i]!=0; i++) {

	mov	DWORD PTR i$[rsp], 0
	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN6@Log
$LN5@Log:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN6@Log:
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	$LN4@Log

; 131  : 		if (s[i]=='\n') {

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	jne	SHORT $LN3@Log

; 132  : 			split[j]=0;	// end of line

	movsxd	rax, DWORD PTR j$[rsp]
	mov	BYTE PTR split$[rsp+rax], 0

; 133  : 			if (split[0]==0) { split[0]=' '; split[1]=0; }

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR split$[rsp+rax]
	test	eax, eax
	jne	SHORT $LN2@Log
	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR split$[rsp+rax], 32		; 00000020H
	mov	eax, 1
	imul	rax, rax, 1
	mov	BYTE PTR split$[rsp+rax], 0
$LN2@Log:

; 134  : 			AddOne(split);

	lea	rcx, QWORD PTR split$[rsp]
	call	?AddOne@@YAXPEBD@Z			; AddOne

; 135  : 			j=0;

	mov	DWORD PTR j$[rsp], 0

; 136  : 		} else {

	jmp	SHORT $LN1@Log
$LN3@Log:

; 137  : 			split[j++]=s[i];

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR j$[rsp]
	mov	rdx, QWORD PTR s$[rsp]
	mov	al, BYTE PTR [rdx+rax]
	mov	BYTE PTR split$[rsp+rcx], al
	mov	eax, DWORD PTR j$[rsp]
	inc	eax
	mov	DWORD PTR j$[rsp], eax
$LN1@Log:

; 138  : 		}
; 139  : 	}

	jmp	$LN5@Log
$LN4@Log:

; 140  : 	split[j]=0;

	movsxd	rax, DWORD PTR j$[rsp]
	mov	BYTE PTR split$[rsp+rax], 0

; 141  : 	AddOne(split);

	lea	rcx, QWORD PTR split$[rsp]
	call	?AddOne@@YAXPEBD@Z			; AddOne

; 142  : }

	add	rsp, 1080				; 00000438H
	ret	0
?Log@@YAXPEBD@Z ENDP					; Log
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
?CloseLog@@YAXXZ PROC					; CloseLog

; 338  : {

$LN70:
	sub	rsp, 40					; 00000028H

; 339  : 	if(LogWriter){

	cmp	QWORD PTR ?LogWriter@@3PEAVIWriter@@EA, 0 ; LogWriter
	je	SHORT $LN1@CloseLog

; 340  : 		FS.w_close(LogWriter);

	lea	rdx, OFFSET FLAT:?LogWriter@@3PEAVIWriter@@EA ; LogWriter
	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	call	?w_close@CLocatorAPI@@QEAAXAEAPEAVIWriter@@@Z ; CLocatorAPI::w_close
$LN1@CloseLog:

; 341  : 	}
; 342  : 
; 343  : 	FlushLog		();

	call	?FlushLog@@YAXXZ			; FlushLog

; 344  :  	LogFile->clear	();

	mov	rcx, QWORD PTR ?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA ; LogFile
	call	?clear@?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAXXZ ; xr_vector<shared_str,xalloc<shared_str> >::clear

; 345  : 	xr_delete		(LogFile);

	lea	rcx, OFFSET FLAT:?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA ; LogFile
	call	??$xr_delete@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z ; xr_delete<xr_vector<shared_str,xalloc<shared_str> > >

; 346  : }

	add	rsp, 40					; 00000028H
	ret	0
?CloseLog@@YAXXZ ENDP					; CloseLog
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
it$1 = 48
tv140 = 56
s$2 = 64
t$3 = 72
ti$4 = 80
buf$5 = 96
nl$ = 176
?CreateLog@@YAXH@Z PROC					; CreateLog

; 310  : {

$LN82:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 168				; 000000a8H

; 311  :     no_log				= nl;

	mov	eax, DWORD PTR nl$[rsp]
	mov	DWORD PTR no_log, eax

; 312  : 	strconcat			(sizeof(logFName),logFName,Core.ApplicationName,"_",Core.UserName,".log");

	lea	rax, OFFSET FLAT:??_C@_04FPOLKAEB@?4log?$AA@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:?Core@@3VxrCore@@A+1104
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:??_C@_01IDAFKMJL@_?$AA@
	lea	r8, OFFSET FLAT:?Core@@3VxrCore@@A	; Core
	lea	rdx, OFFSET FLAT:logFName
	mov	ecx, 520				; 00000208H
	call	?strconcat@@YAPEBDHPEADPEBD111@Z	; strconcat

; 313  : 	if (FS.path_exist("$logs$"))

	lea	rdx, OFFSET FLAT:??_C@_06DMJLOKKG@$logs$?$AA@
	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	call	?path_exist@CLocatorAPI@@QEAA_NPEBD@Z	; CLocatorAPI::path_exist
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@CreateLog

; 314  : 		FS.update_path	(logFName,"$logs$",logFName);

	lea	r9, OFFSET FLAT:logFName
	lea	r8, OFFSET FLAT:??_C@_06DMJLOKKG@$logs$?$AA@
	lea	rdx, OFFSET FLAT:logFName
	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	call	?update_path@CLocatorAPI@@QEAAPEBDAEAY0CAI@DPEBD1@Z ; CLocatorAPI::update_path
$LN6@CreateLog:

; 315  : 	if (!no_log){

	cmp	DWORD PTR no_log, 0
	jne	$LN5@CreateLog

; 316  : 
; 317  : 		LogWriter = FS.w_open	(logFName);

	lea	rdx, OFFSET FLAT:logFName
	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	call	?w_open@CLocatorAPI@@QEAAPEAVIWriter@@PEBD@Z ; CLocatorAPI::w_open
	mov	QWORD PTR ?LogWriter@@3PEAVIWriter@@EA, rax ; LogWriter

; 318  :         if (LogWriter == NULL){

	cmp	QWORD PTR ?LogWriter@@3PEAVIWriter@@EA, 0 ; LogWriter
	jne	SHORT $LN4@CreateLog

; 319  :         	MessageBox	(NULL,"Can't create log file.","Error",MB_ICONERROR);

	mov	r9d, 16
	lea	r8, OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BH@FLDDKOBP@Can?8t?5create?5log?5file?4?$AA@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA

; 320  :         	abort();

	call	QWORD PTR __imp_abort
$LN4@CreateLog:

; 321  :         }		
; 322  : 	
; 323  : 		time_t t = time(NULL);

	xor	ecx, ecx
	call	time
	mov	QWORD PTR t$3[rsp], rax

; 324  : 		tm* ti = localtime(&t);

	lea	rcx, QWORD PTR t$3[rsp]
	call	localtime
	mov	QWORD PTR ti$4[rsp], rax

; 325  : 		char buf[64];
; 326  : 		strftime(buf, 64, "[%x %X]\t", ti);

	mov	r9, QWORD PTR ti$4[rsp]
	lea	r8, OFFSET FLAT:??_C@_08DCHCECCB@?$FL?$CFx?5?$CFX?$FN?7?$AA@
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$5[rsp]
	call	QWORD PTR __imp_strftime

; 327  : 
; 328  :         for (u32 it=0; it<LogFile->size(); it++)	{

	mov	DWORD PTR it$1[rsp], 0
	jmp	SHORT $LN3@CreateLog
$LN2@CreateLog:
	mov	eax, DWORD PTR it$1[rsp]
	inc	eax
	mov	DWORD PTR it$1[rsp], eax
$LN3@CreateLog:
	mov	rcx, QWORD PTR ?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA ; LogFile
	call	?size@?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEBAIXZ ; xr_vector<shared_str,xalloc<shared_str> >::size
	cmp	DWORD PTR it$1[rsp], eax
	jae	SHORT $LN1@CreateLog

; 329  : 			LPCSTR		s	= *((*LogFile)[it]);

	mov	eax, DWORD PTR it$1[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR ?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA ; LogFile
	call	??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAAEAVshared_str@@_K@Z ; xr_vector<shared_str,xalloc<shared_str> >::operator[]
	mov	rcx, rax
	call	??Dshared_str@@QEBAPEBDXZ		; shared_str::operator*
	mov	QWORD PTR s$2[rsp], rax

; 330  : 			LogWriter->w_printf("%s%s\n", buf, s?s:"");

	cmp	QWORD PTR s$2[rsp], 0
	je	SHORT $LN9@CreateLog
	mov	rax, QWORD PTR s$2[rsp]
	mov	QWORD PTR tv140[rsp], rax
	jmp	SHORT $LN10@CreateLog
$LN9@CreateLog:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	mov	QWORD PTR tv140[rsp], rax
$LN10@CreateLog:
	mov	r9, QWORD PTR tv140[rsp]
	lea	r8, QWORD PTR buf$5[rsp]
	lea	rdx, OFFSET FLAT:??_C@_05JMJKDBEJ@?$CFs?$CFs?6?$AA@
	mov	rcx, QWORD PTR ?LogWriter@@3PEAVIWriter@@EA ; LogWriter
	call	?w_printf@IWriter@@QEAAXPEBDZZ		; IWriter::w_printf

; 331  : 		}

	jmp	SHORT $LN2@CreateLog
$LN1@CreateLog:

; 332  : 		LogWriter->flush();

	mov	rax, QWORD PTR ?LogWriter@@3PEAVIWriter@@EA ; LogWriter
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR ?LogWriter@@3PEAVIWriter@@EA ; LogWriter
	call	QWORD PTR [rax+40]
$LN5@CreateLog:

; 333  :     }
; 334  : 	LogFile->reserve		(128);

	mov	edx, 128				; 00000080H
	mov	rcx, QWORD PTR ?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA ; LogFile
	call	?reserve@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAX_K@Z ; std::vector<shared_str,xalloc<shared_str> >::reserve
$LN8@CreateLog:

; 335  : }

	add	rsp, 168				; 000000a8H
	ret	0
?CreateLog@@YAXH@Z ENDP					; CreateLog
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
buf$ = 48
msg$ = 1088
dop$ = 1096
?Log@@YAXPEBDI@Z PROC					; Log

; 226  : void Log				(const char *msg, u32 dop) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1080				; 00000438H

; 227  : 	char buf[1024];
; 228  : 
; 229  : 	sprintf_s	(buf,sizeof(buf),"%s %d",msg,dop);

	mov	eax, DWORD PTR dop$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR msg$[rsp]
	lea	r8, OFFSET FLAT:??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp_sprintf_s

; 230  : 	Log			(buf);

	lea	rcx, QWORD PTR buf$[rsp]
	call	?Log@@YAXPEBD@Z				; Log

; 231  : }

	add	rsp, 1080				; 00000438H
	ret	0
?Log@@YAXPEBDI@Z ENDP					; Log
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
buf$ = 48
msg$ = 1088
dop$ = 1096
?Log@@YAXPEBD0@Z PROC					; Log

; 217  : void Log				(const char *msg, const char *dop) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1080				; 00000438H

; 218  : 	char buf[1024];
; 219  : 
; 220  : 	if (dop)	sprintf_s(buf,sizeof(buf),"%s %s",msg,dop);

	cmp	QWORD PTR dop$[rsp], 0
	je	SHORT $LN2@Log
	mov	rax, QWORD PTR dop$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR msg$[rsp]
	lea	r8, OFFSET FLAT:??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp_sprintf_s
	jmp	SHORT $LN1@Log
$LN2@Log:

; 221  : 	else		sprintf_s(buf,sizeof(buf),"%s",msg);

	mov	r9, QWORD PTR msg$[rsp]
	lea	r8, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp_sprintf_s
$LN1@Log:

; 222  : 
; 223  : 	Log		(buf);

	lea	rcx, QWORD PTR buf$[rsp]
	call	?Log@@YAXPEBD@Z				; Log

; 224  : }

	add	rsp, 1080				; 00000438H
	ret	0
?Log@@YAXPEBD0@Z ENDP					; Log
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
;	COMDAT ??__Everbosity_filters@@YAXXZ
text$di	SEGMENT
??__Everbosity_filters@@YAXXZ PROC			; `dynamic initializer for 'verbosity_filters'', COMDAT

; 13   : str_container				verbosity_filters; // набор фильтров дл€ вывода регул€рных сообщений

	sub	rsp, 40					; 00000028H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 40					; 00000028H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 41   : 	InitializeCriticalSection		( (CRITICAL_SECTION*)pmutex	);

	mov	rcx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	QWORD PTR ?verbosity_filters@@3Vstr_container@@A, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 41   : 	InitializeCriticalSection		( (CRITICAL_SECTION*)pmutex	);

	call	QWORD PTR __imp_InitializeCriticalSection
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

	xor	eax, eax
	mov	QWORD PTR ?verbosity_filters@@3Vstr_container@@A+8, rax

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR ?verbosity_filters@@3Vstr_container@@A+16, rax

; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@PEAUstr_value@@V?$xalloc@PEAUstr_value@@@@@std@@@std@@QEAAPEAU?$_Tree_node@PEAUstr_value@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<str_value * __ptr64,xalloc<str_value * __ptr64> > >::_Buyheadnode
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp

; 13   : str_container				verbosity_filters; // набор фильтров дл€ вывода регул€рных сообщений

	lea	rcx, OFFSET FLAT:??__Fverbosity_filters@@YAXXZ ; `dynamic atexit destructor for 'verbosity_filters''
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 773  : 		this->_Myhead = _Buyheadnode();

	mov	QWORD PTR ?verbosity_filters@@3Vstr_container@@A+8, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp

; 13   : str_container				verbosity_filters; // набор фильтров дл€ вывода регул€рных сообщений

	add	rsp, 40					; 00000028H
	jmp	atexit
??__Everbosity_filters@@YAXXZ ENDP			; `dynamic initializer for 'verbosity_filters''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
;	COMDAT ??__Fverbosity_filters@@YAXXZ
text$yd	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
p$6 = 56
??__Fverbosity_filters@@YAXXZ PROC			; `dynamic atexit destructor for 'verbosity_filters'', COMDAT
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.cpp

; 157  : 	clean	();

	lea	rcx, OFFSET FLAT:?verbosity_filters@@3Vstr_container@@A ; verbosity_filters
	call	?clean@str_container@@QEAAXXZ		; str_container::clean
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

	mov	r8, QWORD PTR ?verbosity_filters@@3Vstr_container@@A+8

; 870  : 		}
; 871  : 	};
; 872  : 
; 873  : 		// TEMPLATE CLASS _Tree_buy
; 874  : template<class _Ty,
; 875  : 	class _Alloc>
; 876  : 	class _Tree_buy
; 877  : 		: public _Tree_alloc<!is_empty<_Alloc>::value,
; 878  : 			_Tree_base_types<_Ty, _Alloc> >
; 879  : 	{	// base class for tree to hold buynode/freenode functions
; 880  : public:
; 881  : 	typedef _Tree_alloc<!is_empty<_Alloc>::value,
; 882  : 		_Tree_base_types<_Ty, _Alloc> > _Mybase;
; 883  : 	typedef typename _Mybase::_Alty _Alty;
; 884  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 885  : 	typedef typename _Mybase::value_type value_type;
; 886  : 
; 887  : 	_Tree_buy(const _Alloc& _Al = _Alloc())
; 888  : 		: _Mybase(_Al)
; 889  : 		{	// construct from allocator
; 890  : 		}
; 891  : 
; 892  : 	_Nodeptr _Buynode0()
; 893  : 		{	// allocate a non-value node
; 894  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 895  : 
; 896  : 		_TRY_BEGIN
; 897  : 		this->_Getal().construct(
; 898  : 			_STD addressof(this->_Left(_Pnode)), this->_Myhead);
; 899  : 		this->_Getal().construct(
; 900  : 			_STD addressof(this->_Parent(_Pnode)), this->_Myhead);
; 901  : 		this->_Getal().construct(
; 902  : 			_STD addressof(this->_Right(_Pnode)), this->_Myhead);
; 903  : 		_CATCH_ALL
; 904  : 		this->_Getal().deallocate(_Pnode, 1);
; 905  : 		_RERAISE;
; 906  : 		_CATCH_END
; 907  : 
; 908  : 		return (_Pnode);
; 909  : 		}
; 910  : 
; 911  : 	void _Freenode0(_Nodeptr _Pnode)
; 912  : 		{	// free non-value node using current allocator
; 913  : 		this->_Getal().destroy(
; 914  : 			_STD addressof(this->_Left(_Pnode)));
; 915  : 		this->_Getal().destroy(
; 916  : 			_STD addressof(this->_Parent(_Pnode)));
; 917  : 		this->_Getal().destroy(
; 918  : 			_STD addressof(this->_Right(_Pnode)));
; 919  : 		this->_Getal().deallocate(_Pnode, 1);
; 920  : 		}
; 921  : 
; 922  : 	template<class... _Valty>
; 923  : 		_Nodeptr _Buynode(_Valty&&... _Val)
; 924  : 		{	// allocate a node with defaults and set links and value
; 925  : 		_Nodeptr _Pnode = _Buynode0();
; 926  : 
; 927  : 		this->_Color(_Pnode) = this->_Red;
; 928  : 		this->_Isnil(_Pnode) = false;
; 929  : 
; 930  : 		_TRY_BEGIN
; 931  : 		this->_Getal().construct(
; 932  : 			_STD addressof(this->_Myval(_Pnode)),
; 933  : 				_STD forward<_Valty>(_Val)...);
; 934  : 		_CATCH_ALL
; 935  : 		_Freenode0(_Pnode);
; 936  : 		_RERAISE;
; 937  : 		_CATCH_END
; 938  : 
; 939  : 		return (_Pnode);
; 940  : 		}
; 941  : 
; 942  : 	};
; 943  : 
; 944  : 		// TEMPLATE CLASS _Tree_comp
; 945  : template<bool _Pr_has_storage,
; 946  : 	class _Traits>
; 947  : 	class _Tree_comp
; 948  : 		: public _Tree_buy<typename _Traits::value_type,
; 949  : 			typename _Traits::allocator_type>
; 950  : 	{	// base class for _Tree to hold ordering predicate with storage
; 951  : public:
; 952  : 	typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
; 953  : 	typedef _Tree_buy<typename _Traits::value_type,
; 954  : 		typename _Traits::allocator_type> _Mybase;
; 955  : 
; 956  : 	typedef typename _Traits::allocator_type allocator_type;
; 957  : 	typedef typename _Traits::key_compare key_compare;
; 958  : 
; 959  : 	_Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
; 960  : 		: _Mybase(_Al), comp(_Parg)
; 961  : 		{	// construct ordering predicate
; 962  : 		}
; 963  : 
; 964  : 	key_compare& _Getcomp()
; 965  : 		{	// get reference to ordering predicate
; 966  : 		return (comp);
; 967  : 		}
; 968  : 
; 969  : 	const key_compare& _Getcomp() const
; 970  : 		{	// get reference to ordering predicate
; 971  : 		return (comp);
; 972  : 		}
; 973  : 
; 974  : 	void _Setcomp(const key_compare& _Right)
; 975  : 		{	// copy ordering predicate
; 976  : 		comp = _Right;
; 977  : 		}
; 978  : 
; 979  : 	void _Swapcomp(key_compare& _Right)
; 980  : 		{	// swap ordering predicate
; 981  : 		_Swap_adl(comp, _Right);
; 982  : 		}
; 983  : 
; 984  : 	key_compare comp;
; 985  : 	};
; 986  : 
; 987  : template<class _Traits>
; 988  : 	class _Tree_comp<false, _Traits>
; 989  : 		: public _Tree_buy<typename _Traits::value_type,
; 990  : 			typename _Traits::allocator_type>
; 991  : 	{	// base class for _Tree to hold ordering predicate with no storage
; 992  : public:
; 993  : 	typedef _Tree_comp<false, _Traits> _Myt;
; 994  : 	typedef _Tree_buy<typename _Traits::value_type,
; 995  : 		typename _Traits::allocator_type> _Mybase;
; 996  : 
; 997  : 	typedef typename _Traits::allocator_type allocator_type;
; 998  : 	typedef typename _Traits::key_compare key_compare;
; 999  : 
; 1000 : 	_Tree_comp(const key_compare&, const allocator_type& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct ordering predicate
; 1003 : 		}
; 1004 : 
; 1005 : 	key_compare _Getcomp() const
; 1006 : 		{	// get ordering predicate
; 1007 : 		return (key_compare());
; 1008 : 		}
; 1009 : 
; 1010 : 	void _Setcomp(const key_compare&)
; 1011 : 		{	// copy ordering predicate
; 1012 : 		}
; 1013 : 
; 1014 : 	void _Swapcomp(const key_compare&)
; 1015 : 		{	// swap ordering predicate
; 1016 : 		}
; 1017 : 	};
; 1018 : 
; 1019 : 		// TEMPLATE CLASS _Tree
; 1020 : template<class _Traits>
; 1021 : 	class _Tree
; 1022 : 		: public _Tree_comp<
; 1023 : 			!is_empty<typename _Traits::key_compare>::value, _Traits>
; 1024 : 	{	// ordered red-black tree for [multi_]{map set}
; 1025 : public:
; 1026 : 	typedef _Tree<_Traits> _Myt;
; 1027 : 	typedef _Tree_comp<
; 1028 : 		!is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;
; 1029 : 
; 1030 : 	typedef typename _Traits::key_type key_type;
; 1031 : 	typedef typename _Traits::value_compare value_compare;
; 1032 : 	enum
; 1033 : 		{	// get multi parameter
; 1034 : 		_Multi = _Traits::_Multi};
; 1035 : 
; 1036 : 	typedef typename _Mybase::_Node _Node;
; 1037 : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 1038 : 	typedef typename _Mybase::_Alty _Alty;
; 1039 : 
; 1040 : 	typedef typename _Mybase::key_compare key_compare;
; 1041 : 	typedef typename _Mybase::allocator_type allocator_type;
; 1042 : 
; 1043 : 	typedef typename _Mybase::value_type value_type;
; 1044 : 	typedef typename _Mybase::size_type size_type;
; 1045 : 	typedef typename _Mybase::difference_type difference_type;
; 1046 : 	typedef typename _Mybase::pointer pointer;
; 1047 : 	typedef typename _Mybase::const_pointer const_pointer;
; 1048 : 	typedef typename _Mybase::reference reference;
; 1049 : 	typedef typename _Mybase::const_reference const_reference;
; 1050 : 
; 1051 : 	typedef typename _Mybase::const_iterator const_iterator;
; 1052 : 	typedef typename _If<is_same<key_type, value_type>::value,
; 1053 : 		typename _Mybase::const_iterator,
; 1054 : 		typename _Mybase::iterator>::type iterator;
; 1055 : 
; 1056 : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 1057 : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 1058 : 
; 1059 : 	typedef pair<iterator, bool> _Pairib;
; 1060 : 	typedef pair<iterator, iterator> _Pairii;
; 1061 : 	typedef pair<const_iterator, const_iterator> _Paircc;
; 1062 : 
; 1063 : 	_Tree(const key_compare& _Parg,
; 1064 : 		const allocator_type& _Al)
; 1065 : 		: _Mybase(_Parg, _Al)
; 1066 : 		{	// construct empty tree
; 1067 : 		}
; 1068 : 
; 1069 : 	_Tree(const value_type *_First, const value_type *_Last,
; 1070 : 		const key_compare& _Parg, const allocator_type& _Al)
; 1071 : 		: _Mybase(_Parg, _Al)
; 1072 : 		{	// construct tree from [_First, _Last) array
; 1073 : 		_TRY_BEGIN
; 1074 : 		insert(_First, _Last);
; 1075 : 		_CATCH_ALL
; 1076 : 		_Tidy();
; 1077 : 		_RERAISE;
; 1078 : 		_CATCH_END
; 1079 : 		}
; 1080 : 
; 1081 : 	_Tree(const _Myt& _Right, const allocator_type& _Al)
; 1082 : 		: _Mybase(_Right.key_comp(), _Al)
; 1083 : 		{	// construct tree by copying _Right, allocator
; 1084 : 		_TRY_BEGIN
; 1085 : 		_Copy(_Right, false_type());
; 1086 : 		_CATCH_ALL
; 1087 : 		_Tidy();
; 1088 : 		_RERAISE;
; 1089 : 		_CATCH_END
; 1090 : 		}
; 1091 : 
; 1092 : 	_Tree(_Myt&& _Right)
; 1093 : 		: _Mybase(_Right.key_comp(), _Right._Getal())
; 1094 : 		{	// construct tree by moving _Right
; 1095 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1096 : 		}
; 1097 : 
; 1098 : 	_Tree(_Myt&& _Right, const allocator_type& _Al)
; 1099 : 		: _Mybase(_Right.key_comp(), _Al)
; 1100 : 		{	// construct tree by moving _Right, allocator
; 1101 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1102 : 		}
; 1103 : 
; 1104 : 	_Myt& operator=(_Myt&& _Right)
; 1105 : 		{	// assign by moving _Right
; 1106 : 		if (this != &_Right)
; 1107 : 			{	// different, move it
; 1108 : 			clear();
; 1109 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1110 : 				&& this->_Getal() != _Right._Getal())
; 1111 : 				this->_Change_alloc(_Right._Getal());
; 1112 : 
; 1113 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1114 : 			}
; 1115 : 		return (*this);
; 1116 : 		}
; 1117 : 
; 1118 : 	void _Assign_rv(_Myt&& _Right, true_type)
; 1119 : 		{	// move from _Right, stealing its contents
; 1120 : 		this->_Swap_all(_Right);
; 1121 : 		this->_Swapcomp(_Right._Getcomp());
; 1122 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1123 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1124 : 		}
; 1125 : 
; 1126 : 	void _Assign_rv(_Myt&& _Right, false_type)
; 1127 : 		{	// move from _Right, possibly moving its contents
; 1128 : 		if (get_allocator() == _Right.get_allocator())
; 1129 : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1130 : 		else
; 1131 : 			_Copy(_Right, true_type());
; 1132 : 		}
; 1133 : 
; 1134 : 	void _Assign_rv(_Myt&& _Right)
; 1135 : 		{	// assign by moving _Right
; 1136 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1137 : 			typename _Alty::propagate_on_container_move_assignment());
; 1138 : 		}
; 1139 : 
; 1140 : 
; 1141 : 	_Pairib insert(value_type&& _Val)
; 1142 : 		{	// try to insert node with value _Val, favoring right side
; 1143 : 		return (_Insert_nohint(false,
; 1144 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1145 : 		}
; 1146 : 
; 1147 : 	iterator insert(const_iterator _Where, value_type&& _Val)
; 1148 : 		{	// try to insert node with value _Val using _Where as a hint
; 1149 : 		return (_Insert_hint(_Where,
; 1150 : 			_STD forward<value_type>(_Val), _Nil_obj));
; 1151 : 		}
; 1152 : 
; 1153 : 	template<class _Valty>
; 1154 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1155 : 			_Pairib>::type
; 1156 : 		insert(_Valty&& _Val)
; 1157 : 		{	// try to insert node with value _Val, favoring right side
; 1158 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1159 : 		return (_Insert_nohint(false,
; 1160 : 			this->_Myval(_Newnode), _Newnode));
; 1161 : 		}
; 1162 : 
; 1163 : 	template<class _Valty>
; 1164 : 		typename enable_if<is_convertible<_Valty, value_type>::value,
; 1165 : 			iterator>::type
; 1166 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1167 : 		{	// try to insert node with value _Val using _Where as a hint
; 1168 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));
; 1169 : 		return (_Insert_hint(_Where,
; 1170 : 			this->_Myval(_Newnode), _Newnode));
; 1171 : 		}
; 1172 : 
; 1173 : 	template<class... _Valty>
; 1174 : 		_Pairib emplace(_Valty&&... _Val)
; 1175 : 		{	// try to insert value_type(_Val...), favoring right side
; 1176 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1177 : 		return (_Insert_nohint(false,
; 1178 : 			this->_Myval(_Newnode), _Newnode));
; 1179 : 		}
; 1180 : 
; 1181 : 	template<class... _Valty>
; 1182 : 		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
; 1183 : 		{	// insert value_type(_Val...) at _Where
; 1184 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);
; 1185 : 		return (_Insert_hint(_Where,
; 1186 : 			this->_Myval(_Newnode), _Newnode));
; 1187 : 		}
; 1188 : 
; 1189 : 
; 1190 : 	~_Tree() _NOEXCEPT
; 1191 : 		{	// destroy tree
; 1192 : 		_Tidy();
; 1193 : 		}
; 1194 : 
; 1195 : 	_Myt& operator=(const _Myt& _Right)
; 1196 : 		{	// replace contents from _Right
; 1197 : 		if (this != &_Right)
; 1198 : 			{	// different, assign it
; 1199 : 			clear();
; 1200 : 			if (this->_Getal() != _Right._Getal()
; 1201 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1202 : 				this->_Change_alloc(_Right._Getal());
; 1203 : 
; 1204 : 			this->_Setcomp(_Right._Getcomp());
; 1205 : 			_Copy(_Right, false_type());
; 1206 : 			}
; 1207 : 		return (*this);
; 1208 : 		}
; 1209 : 
; 1210 : 	iterator begin() _NOEXCEPT
; 1211 : 		{	// return iterator for beginning of mutable sequence
; 1212 : 		return (iterator(_Lmost(), this));
; 1213 : 		}
; 1214 : 
; 1215 : 	const_iterator begin() const _NOEXCEPT
; 1216 : 		{	// return iterator for beginning of nonmutable sequence
; 1217 : 		return (const_iterator(_Lmost(), this));
; 1218 : 		}
; 1219 : 
; 1220 : 	iterator end() _NOEXCEPT
; 1221 : 		{	// return iterator for end of mutable sequence
; 1222 : 		return (iterator(this->_Myhead, this));
; 1223 : 		}
; 1224 : 
; 1225 : 	const_iterator end() const _NOEXCEPT
; 1226 : 		{	// return iterator for end of nonmutable sequence
; 1227 : 		return (const_iterator(this->_Myhead, this));
; 1228 : 		}
; 1229 : 
; 1230 : 	reverse_iterator rbegin() _NOEXCEPT
; 1231 : 		{	// return iterator for beginning of reversed mutable sequence
; 1232 : 		return (reverse_iterator(end()));
; 1233 : 		}
; 1234 : 
; 1235 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1236 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1237 : 		return (const_reverse_iterator(end()));
; 1238 : 		}
; 1239 : 
; 1240 : 	reverse_iterator rend() _NOEXCEPT
; 1241 : 		{	// return iterator for end of reversed mutable sequence
; 1242 : 		return (reverse_iterator(begin()));
; 1243 : 		}
; 1244 : 
; 1245 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1246 : 		{	// return iterator for end of reversed nonmutable sequence
; 1247 : 		return (const_reverse_iterator(begin()));
; 1248 : 		}
; 1249 : 
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 : 
; 1270 : 	size_type size() const _NOEXCEPT
; 1271 : 		{	// return length of sequence
; 1272 : 		return (this->_Mysize);
; 1273 : 		}
; 1274 : 
; 1275 : 	size_type max_size() const _NOEXCEPT
; 1276 : 		{	// return maximum possible length of sequence
; 1277 : 		return (this->_Getal().max_size());
; 1278 : 		}
; 1279 : 
; 1280 : 	bool empty() const _NOEXCEPT
; 1281 : 		{	// return true only if sequence is empty
; 1282 : 		return (size() == 0);
; 1283 : 		}
; 1284 : 
; 1285 : 	allocator_type get_allocator() const _NOEXCEPT
; 1286 : 		{	// return allocator object for values
; 1287 : 		return (this->_Getal());
; 1288 : 		}
; 1289 : 
; 1290 : 	key_compare key_comp() const
; 1291 : 		{	// return object for comparing keys
; 1292 : 		return (this->_Getcomp());
; 1293 : 		}
; 1294 : 
; 1295 : 	value_compare value_comp() const
; 1296 : 		{	// return object for comparing values
; 1297 : 		return (value_compare(key_comp()));
; 1298 : 		}
; 1299 : 
; 1300 : 	_Pairib insert(const value_type& _Val)
; 1301 : 		{	// try to insert node with value _Val, favoring right side
; 1302 : 		return (_Insert_nohint(false,
; 1303 : 			_Val, _Nil_obj));
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where,
; 1307 : 		const value_type& _Val)
; 1308 : 		{	// try to insert node with value _Val using _Where as a hint
; 1309 : 		return (_Insert_hint(_Where,
; 1310 : 			_Val, _Nil_obj));
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		void insert(_Iter _First, _Iter _Last)
; 1315 : 		{	// insert [_First, _Last) one at a time
; 1316 : 		_DEBUG_RANGE(_First, _Last);
; 1317 : 		for (; _First != _Last; ++_First)
; 1318 : 
; 1319 : 			emplace_hint(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	void insert(_XSTD initializer_list<value_type> _Ilist)
; 1323 : 		{	// insert initializer_list
; 1324 : 		insert(_Ilist.begin(), _Ilist.end());
; 1325 : 		}
; 1326 : 
; 1327 : 	iterator erase(const_iterator _Where)
; 1328 : 		{	// erase element at _Where
; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1338 : 		++_Where;	// save successor iterator for return
; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;
; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1349 : 		else
; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)
; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1358 : 			if (!this->_Isnil(_Fixnode))
; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)
; 1362 : 				_Root() = _Fixnode;	// link down from root
; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1365 : 			else
; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right
; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)
; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)
; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1378 : 			}
; 1379 : 		else
; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up
; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down
; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))
; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1388 : 			else
; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's
; 1392 : 				if (!this->_Isnil(_Fixnode))
; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down
; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up
; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)
; 1402 : 				_Root() = _Pnode;	// link down from root
; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left
; 1406 : 			else
; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right
; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up
; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it
; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1424 : 					if (this->_Color(_Pnode) == this->_Red)
; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;
; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1428 : 						_Lrotate(_Fixnodeparent);
; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))
; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;
; 1438 : 						_Fixnode = _Fixnodeparent;
; 1439 : 						}
; 1440 : 					else
; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)
; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1446 : 							this->_Color(_Pnode) = this->_Red;
; 1447 : 							_Rrotate(_Pnode);
; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1454 : 						_Lrotate(_Fixnodeparent);
; 1455 : 						break;	// tree now recolored/rebalanced
; 1456 : 						}
; 1457 : 					}
; 1458 : 				else
; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1461 : 					if (this->_Color(_Pnode) == this->_Red)
; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;
; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1465 : 						_Rrotate(_Fixnodeparent);
; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))
; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;
; 1476 : 						_Fixnode = _Fixnodeparent;
; 1477 : 						}
; 1478 : 					else
; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1483 : 							this->_Color(_Pnode) = this->_Red;
; 1484 : 							_Lrotate(_Pnode);
; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1491 : 						_Rrotate(_Fixnodeparent);
; 1492 : 						break;	// tree now recolored/rebalanced
; 1493 : 						}
; 1494 : 					}
; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1503 : 
; 1504 : 		if (0 < this->_Mysize)
; 1505 : 			--this->_Mysize;
; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1508 : 		}
; 1509 : 
; 1510 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1511 : 		{	// erase [_First, _Last)
; 1512 : 		if (_First == begin() && _Last == end())
; 1513 : 			{	// erase all
; 1514 : 			clear();
; 1515 : 			return (begin());
; 1516 : 			}
; 1517 : 		else
; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)
; 1520 : 				erase(_First++);
; 1521 : 			return (iterator(_First._Ptr, this));
; 1522 : 			}
; 1523 : 		}
; 1524 : 
; 1525 : 	size_type erase(const key_type& _Keyval)
; 1526 : 		{	// erase and count all that match _Keyval
; 1527 : 		_Pairii _Where = equal_range(_Keyval);
; 1528 : 		size_type _Num = 0;
; 1529 : 		_Distance(_Where.first, _Where.second, _Num);
; 1530 : 		erase(_Where.first, _Where.second);
; 1531 : 		return (_Num);
; 1532 : 		}
; 1533 : 
; 1534 : 	void clear() _NOEXCEPT
; 1535 : 		{	// erase all
; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());
; 1541 : 		_Root() = this->_Myhead;
; 1542 : 		_Lmost() = this->_Myhead;
; 1543 : 		_Rmost() = this->_Myhead;
; 1544 : 		this->_Mysize = 0;
; 1545 : 		}
; 1546 : 
; 1547 : 	iterator find(const key_type& _Keyval)
; 1548 : 		{	// find an element in mutable sequence that matches _Keyval
; 1549 : 		iterator _Where = lower_bound(_Keyval);
; 1550 : 		return (_Where == end()
; 1551 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1552 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1553 : 					? end() : _Where);
; 1554 : 		}
; 1555 : 
; 1556 : 	const_iterator find(const key_type& _Keyval) const
; 1557 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1558 : 		const_iterator _Where = lower_bound(_Keyval);
; 1559 : 		return (_Where == end()
; 1560 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1561 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1562 : 					? end() : _Where);
; 1563 : 		}
; 1564 : 
; 1565 : 	size_type count(const key_type& _Keyval) const
; 1566 : 		{	// count all elements that match _Keyval
; 1567 : 		_Paircc _Ans = equal_range(_Keyval);
; 1568 : 		size_type _Num = 0;
; 1569 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1570 : 		return (_Num);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator lower_bound(const key_type& _Keyval)
; 1574 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1575 : 		return (iterator(_Lbound(_Keyval), this));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1579 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1580 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator upper_bound(const key_type& _Keyval)
; 1584 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1585 : 		return (iterator(_Ubound(_Keyval), this));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1589 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1590 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1591 : 		}
; 1592 : 
; 1593 : 	_Pairii equal_range(const key_type& _Keyval)
; 1594 : 		{	// find range equivalent to _Keyval in mutable tree
; 1595 : 		return (_Eqrange(_Keyval));
; 1596 : 		}
; 1597 : 
; 1598 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1599 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1600 : 		return (_Eqrange(_Keyval));
; 1601 : 		}
; 1602 : 
; 1603 : 	void swap(_Myt& _Right)
; 1604 : 		{	// exchange contents with _Right
; 1605 : 		if (this == &_Right)
; 1606 : 			;	// same object, do nothing
; 1607 : 		else if (this->_Getal() == _Right._Getal())
; 1608 : 			{	// same allocator, swap control information
; 1609 : 			this->_Swap_all(_Right);
; 1610 : 			this->_Swapcomp(_Right._Getcomp());
; 1611 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1612 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1613 : 			}
; 1614 : 
; 1615 : 		else if (_Alty::propagate_on_container_swap::value)
; 1616 : 			{	// swap allocators and control information
; 1617 : 			this->_Swap_alloc(_Right);
; 1618 : 			this->_Swapcomp(_Right._Getcomp());
; 1619 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1620 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1621 : 			}
; 1622 : 
; 1623 : 		else
; 1624 : 			{	// containers are incompatible
; 1625 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1626 : 			_DEBUG_ERROR("map/set containers incompatible for swap");
; 1627 : 
; 1628 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1629 : 			_XSTD terminate();
; 1630 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1631 : 			}
; 1632 : 		}
; 1633 : 
; 1634 : protected:
; 1635 : 	template<class _Valty>
; 1636 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1637 : 		{	// node exists, just return it
; 1638 : 		return (_Node);
; 1639 : 		}
; 1640 : 
; 1641 : 	template<class _Valty>
; 1642 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1643 : 		{	// node doesn't exist, make it
; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1645 : 		}
; 1646 : 
; 1647 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1648 : 		{	// node exists, destroy it
; 1649 : 		this->_Getal().destroy(
; 1650 : 			_STD addressof(this->_Myval(_Newnode)));
; 1651 : 
; 1652 : 		this->_Getal().deallocate(_Newnode, 1);
; 1653 : 		}
; 1654 : 
; 1655 : 	void _Destroy_if_not_nil(_Nil)
; 1656 : 		{	// node doesn't exist, do nothing
; 1657 : 		}
; 1658 : 
; 1659 : 	template<class _Valty,
; 1660 : 		class _Nodety>
; 1661 : 		iterator _Insert_hint(const_iterator _Where,
; 1662 : 			_Valty&& _Val, _Nodety _Newnode)
; 1663 : 		{	// try to insert node using _Where as a hint
; 1664 : 		const_iterator _Next;
; 1665 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1666 : 
; 1667 : 		_TRY_BEGIN
; 1668 : 
; 1669 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1670 : 		if (_Where._Getcont() != this)
; 1671 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1672 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1673 : 
; 1674 : 		if (size() == 0)
; 1675 : 			return (_Insert_at(true, this->_Myhead,
; 1676 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1677 : 		else if (this->_Multi)
; 1678 : 			{	// insert even if duplicate
; 1679 : 			if (_Where == begin())
; 1680 : 				{	// insert at beginning if before first element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1683 : 					return (_Insert_at(true, _Where._Mynode(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1686 : 				}
; 1687 : 			else if (_Where == end())
; 1688 : 				{	// insert at end if after last element
; 1689 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1690 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1691 : 					return (_Insert_at(false, _Rmost(),
; 1692 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1693 : 				}
; 1694 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1695 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1696 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1697 : 					this->_Kfn(_Val),
; 1698 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1699 : 				{	// insert before _Where
; 1700 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1701 : 					return (_Insert_at(false, _Next._Mynode(),
; 1702 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1703 : 				else
; 1704 : 					return (_Insert_at(true, _Where._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				}
; 1707 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1708 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1709 : 				&& (++(_Next = _Where) == end()
; 1710 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1712 : 				{	// insert after _Where
; 1713 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1714 : 					return (_Insert_at(false, _Where._Mynode(),
; 1715 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1716 : 				else
; 1717 : 					return (_Insert_at(true, _Next._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				}
; 1720 : 			else
; 1721 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1722 : 			}
; 1723 : 		else
; 1724 : 			{	// insert only if unique
; 1725 : 			if (_Where == begin())
; 1726 : 				{	// insert at beginning if before first element
; 1727 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1728 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1729 : 					return (_Insert_at(true, _Where._Mynode(),
; 1730 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1731 : 				}
; 1732 : 			else if (_Where == end())
; 1733 : 				{	// insert at end if after last element
; 1734 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1735 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1736 : 					return (_Insert_at(false, _Rmost(),
; 1737 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1738 : 				}
; 1739 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1740 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1741 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1742 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1743 : 					this->_Kfn(_Val)))
; 1744 : 				{	// insert before _Where
; 1745 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1746 : 					return (_Insert_at(false, _Next._Mynode(),
; 1747 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1748 : 				else
; 1749 : 					return (_Insert_at(true, _Where._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				}
; 1752 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1753 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1754 : 				&& (++(_Next = _Where) == end()
; 1755 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1757 : 				{	// insert after _Where
; 1758 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1759 : 					return (_Insert_at(false, _Where._Mynode(),
; 1760 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1761 : 				else
; 1762 : 					return (_Insert_at(true, _Next._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				}
; 1765 : 			}
; 1766 : 		_CATCH_ALL
; 1767 : 		_Destroy_if_not_nil(_Newnode);
; 1768 : 		_RERAISE;
; 1769 : 		_CATCH_END
; 1770 : 
; 1771 : 		return (_Insert_nohint(_Leftish,
; 1772 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1773 : 		}
; 1774 : 
; 1775 : 	template<class _Valty,
; 1776 : 		class _Nodety>
; 1777 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1778 : 			_Valty&& _Val, _Nodety _Newnode)
; 1779 : 		{	// try to insert node, on left if _Leftish
; 1780 : 		_TRY_BEGIN
; 1781 : 		_Nodeptr _Trynode = _Root();
; 1782 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1783 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1784 : 
; 1785 : 		while (!this->_Isnil(_Trynode))
; 1786 : 			{	// look for leaf to insert before (_Addleft) or after
; 1787 : 			_Wherenode = _Trynode;
; 1788 : 			if (_Leftish)
; 1789 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1790 : 					this->_Key(_Trynode),
; 1791 : 					this->_Kfn(_Val));	// favor left end
; 1792 : 			else
; 1793 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1794 : 					this->_Kfn(_Val),
; 1795 : 					this->_Key(_Trynode));	// favor right end
; 1796 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1797 : 				: this->_Right(_Trynode);
; 1798 : 			}
; 1799 : 
; 1800 : 		if (this->_Multi)
; 1801 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1802 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 		else
; 1804 : 			{	// insert only if unique
; 1805 : 			iterator _Where = iterator(_Wherenode, this);
; 1806 : 			if (!_Addleft)
; 1807 : 				;	// need to test if insert after is okay
; 1808 : 			else if (_Where == begin())
; 1809 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				--_Where;	// need to test if insert before is okay
; 1813 : 
; 1814 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1815 : 				this->_Key(_Where._Mynode()),
; 1816 : 				this->_Kfn(_Val)))
; 1817 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1818 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1819 : 			else
; 1820 : 				{	// duplicate, don't insert
; 1821 : 				_Destroy_if_not_nil(_Newnode);
; 1822 : 				return (_Pairib(_Where, false));
; 1823 : 				}
; 1824 : 			}
; 1825 : 		_CATCH_ALL
; 1826 : 		_Destroy_if_not_nil(_Newnode);
; 1827 : 		_RERAISE;
; 1828 : 		_CATCH_END
; 1829 : 		}
; 1830 : 
; 1831 : 	template<class _Valty,
; 1832 : 		class _Nodety>
; 1833 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1834 : 		_Valty&& _Val, _Nodety _Node)
; 1835 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1836 : 		if (max_size() - 1 <= this->_Mysize)
; 1837 : 			{	// tree would get too big, fail
; 1838 : 			_Destroy_if_not_nil(_Node);
; 1839 : 			_Xlength_error("map/set<T> too long");
; 1840 : 			}
; 1841 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1842 : 			_STD forward<_Valty>(_Val));
; 1843 : 
; 1844 : 		++this->_Mysize;
; 1845 : 		_Newnode->_Parent = _Wherenode;
; 1846 : 
; 1847 : 		if (_Wherenode == this->_Myhead)
; 1848 : 			{	// first node in tree, just set head values
; 1849 : 			_Root() = _Newnode;
; 1850 : 			_Lmost() = _Newnode;
; 1851 : 			_Rmost() = _Newnode;
; 1852 : 			}
; 1853 : 		else if (_Addleft)
; 1854 : 			{	// add to left of _Wherenode
; 1855 : 			this->_Left(_Wherenode) = _Newnode;
; 1856 : 			if (_Wherenode == _Lmost())
; 1857 : 				_Lmost() = _Newnode;
; 1858 : 			}
; 1859 : 		else
; 1860 : 			{	// add to right of _Wherenode
; 1861 : 			this->_Right(_Wherenode) = _Newnode;
; 1862 : 			if (_Wherenode == _Rmost())
; 1863 : 				_Rmost() = _Newnode;
; 1864 : 			}
; 1865 : 
; 1866 : 		for (_Nodeptr _Pnode = _Newnode;
; 1867 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1868 : 			if (this->_Parent(_Pnode)
; 1869 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1870 : 				{	// fixup red-red in left subtree
; 1871 : 				_Wherenode =
; 1872 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1873 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1874 : 					{	// parent has two red children, blacken both
; 1875 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1876 : 					this->_Color(_Wherenode) = this->_Black;
; 1877 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1878 : 						= this->_Red;
; 1879 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1880 : 					}
; 1881 : 				else
; 1882 : 					{	// parent has red and black children
; 1883 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1884 : 						{	// rotate right child to left
; 1885 : 						_Pnode = this->_Parent(_Pnode);
; 1886 : 						_Lrotate(_Pnode);
; 1887 : 						}
; 1888 : 					this->_Color(this->_Parent(_Pnode)) =
; 1889 : 						this->_Black;	// propagate red up
; 1890 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1891 : 						this->_Red;
; 1892 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1893 : 					}
; 1894 : 				}
; 1895 : 			else
; 1896 : 				{	// fixup red-red in right subtree
; 1897 : 				_Wherenode =
; 1898 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1899 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1900 : 					{	// parent has two red children, blacken both
; 1901 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1902 : 					this->_Color(_Wherenode) = this->_Black;
; 1903 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1904 : 						this->_Red;
; 1905 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1906 : 					}
; 1907 : 				else
; 1908 : 					{	// parent has red and black children
; 1909 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1910 : 						{	// rotate left child to right
; 1911 : 						_Pnode = this->_Parent(_Pnode);
; 1912 : 						_Rrotate(_Pnode);
; 1913 : 						}
; 1914 : 					this->_Color(this->_Parent(_Pnode)) =
; 1915 : 						this->_Black;	// propagate red up
; 1916 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1917 : 						this->_Red;
; 1918 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1919 : 					}
; 1920 : 				}
; 1921 : 
; 1922 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1923 : 		return (iterator(_Newnode, this));
; 1924 : 		}
; 1925 : 
; 1926 : 	template<class _Moveit>
; 1927 : 		void _Copy(const _Myt& _Right,
; 1928 : 			_Moveit _Movefl)
; 1929 : 		{	// copy or move entire tree from _Right
; 1930 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1931 : 		this->_Mysize = _Right.size();
; 1932 : 		if (!this->_Isnil(_Root()))
; 1933 : 			{	// nonempty tree, look for new smallest and largest
; 1934 : 			_Lmost() = this->_Min(_Root());
; 1935 : 			_Rmost() = this->_Max(_Root());
; 1936 : 			}
; 1937 : 		else
; 1938 : 			{	// empty tree, just tidy head pointers
; 1939 : 			_Lmost() = this->_Myhead;
; 1940 : 			_Rmost() = this->_Myhead;
; 1941 : 			}
; 1942 : 		}
; 1943 : 
; 1944 : 	template<class _Want_to_move,
; 1945 : 		class _Can_move,
; 1946 : 		class _Is_set,
; 1947 : 		class _Dummy>
; 1948 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
; 1949 : 			_Can_move, _Is_set, _Dummy)
; 1950 : 		{	// copy to new node -- nonmovable
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	template<class _Dummy>
; 1955 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1956 : 			true_type, true_type, _Dummy)
; 1957 : 		{	// move to new node -- movable, set
; 1958 : 		return (this->_Buynode(
; 1959 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1960 : 		}
; 1961 : 
; 1962 : 	template<class _Dummy>
; 1963 : 		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
; 1964 : 			true_type, false_type, _Dummy)
; 1965 : 		{	// move to new node -- movable, map
; 1966 : 		return (this->_Buynode(
; 1967 : 			_STD forward<key_type>(const_cast<key_type&>(
; 1968 : 				this->_Myval(_Rootnode).first)),
; 1969 : 			_STD forward<typename value_type::second_type>(this->_Myval(
; 1970 : 				_Rootnode).second)));
; 1971 : 		}
; 1972 : 
; 1973 : 	template<class _Moveit>
; 1974 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1975 : 			_Moveit _Movefl)
; 1976 : 		{	// copy entire subtree, recursively
; 1977 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1978 : 
; 1979 : 		if (!this->_Isnil(_Rootnode))
; 1980 : 			{	// copy or move a node, then any subtrees
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1982 : 				typename is_move_constructible<value_type>::type(),
; 1983 : 				typename is_same<key_type, value_type>::type(), 0);
; 1984 : 			_Pnode->_Parent = _Wherenode;
; 1985 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1986 : 			if (this->_Isnil(_Newroot))
; 1987 : 				_Newroot = _Pnode;	// memorize new root
; 1988 : 
; 1989 : 			_TRY_BEGIN
; 1990 : 			this->_Left(_Pnode) =
; 1991 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1992 : 			this->_Right(_Pnode) =
; 1993 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1994 : 			_CATCH_ALL
; 1995 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1996 : 			_RERAISE;
; 1997 : 			_CATCH_END
; 1998 : 			}
; 1999 : 
; 2000 : 		return (_Newroot);	// return newly constructed tree
; 2001 : 		}
; 2002 : 
; 2003 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 2004 : 		{	// find leftmost node not less than _Keyval
; 2005 : 		_Nodeptr _Pnode = _Root();
; 2006 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))
; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2012 : 			else
; 2013 : 				{	// _Pnode not less than _Keyval, remember it
; 2014 : 				if (this->_Isnil(_Hinode)
; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;
; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))
; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;
; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2029 : 				}
; 2030 : 			else
; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2032 : 
; 2033 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2034 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2035 : 		return (_Paircc(_First, _Last));
; 2036 : 		}
; 2037 : 
; 2038 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2039 : 		{	// find leftmost node not less than _Keyval
; 2040 : 		_Nodeptr _Pnode = _Root();
; 2041 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2042 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2043 : 
; 2044 : 		while (!this->_Isnil(_Pnode))
; 2045 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2046 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2047 : 			else
; 2048 : 				{	// _Pnode not less than _Keyval, remember it
; 2049 : 				if (this->_Isnil(_Hinode)
; 2050 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2051 : 						 this->_Key(_Pnode)))
; 2052 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2053 : 				_Lonode = _Pnode;
; 2054 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2055 : 				}
; 2056 : 
; 2057 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2058 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2059 : 		while (!this->_Isnil(_Pnode))
; 2060 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2061 : 				{	// _Pnode greater than _Keyval, remember it
; 2062 : 				_Hinode = _Pnode;
; 2063 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2064 : 				}
; 2065 : 			else
; 2066 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2067 : 
; 2068 : 		iterator _First = iterator(_Lonode, this);
; 2069 : 		iterator _Last = iterator(_Hinode, this);
; 2070 : 		return (_Pairii(_First, _Last));
; 2071 : 		}
; 2072 : 
; 2073 : 	void _Erase(_Nodeptr _Rootnode)
; 2074 : 		{	// free entire subtree, recursively
; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));
; 2079 : 			_Pnode = this->_Left(_Pnode);
; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2084 : 			}
; 2085 : 		}
; 2086 : 
; 2087 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2088 : 		{	// find leftmost node not less than _Keyval
; 2089 : 		_Nodeptr _Pnode = _Root();
; 2090 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2091 : 
; 2092 : 		while (!this->_Isnil(_Pnode))
; 2093 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2094 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2095 : 			else
; 2096 : 				{	// _Pnode not less than _Keyval, remember it
; 2097 : 				_Wherenode = _Pnode;
; 2098 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2099 : 				}
; 2100 : 
; 2101 : 		return (_Wherenode);	// return best remembered candidate
; 2102 : 		}
; 2103 : 
; 2104 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2105 : 		{	// find leftmost node not less than _Keyval
; 2106 : 		_Nodeptr _Pnode = _Root();
; 2107 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2108 : 
; 2109 : 		while (!this->_Isnil(_Pnode))
; 2110 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2111 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2112 : 			else
; 2113 : 				{	// _Pnode not less than _Keyval, remember it
; 2114 : 				_Wherenode = _Pnode;
; 2115 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2116 : 				}
; 2117 : 
; 2118 : 		return (_Wherenode);	// return best remembered candidate
; 2119 : 		}
; 2120 : 
; 2121 : 	_Nodeptr& _Lmost() const
; 2122 : 		{	// return leftmost node in nonmutable tree
; 2123 : 		return (this->_Left(this->_Myhead));
; 2124 : 		}
; 2125 : 
; 2126 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2127 : 		{	// promote right node to root of subtree
; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2134 : 
; 2135 : 		if (_Wherenode == _Root())
; 2136 : 			_Root() = _Pnode;
; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2139 : 		else
; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;
; 2143 : 		this->_Parent(_Wherenode) = _Pnode;
; 2144 : 		}
; 2145 : 
; 2146 : 	_Nodeptr& _Rmost() const
; 2147 : 		{	// return rightmost node in nonmutable tree
; 2148 : 		return (this->_Right(this->_Myhead));
; 2149 : 		}
; 2150 : 
; 2151 : 	_Nodeptr& _Root() const
; 2152 : 		{	// return root of nonmutable tree
; 2153 : 		return (this->_Parent(this->_Myhead));
; 2154 : 		}
; 2155 : 
; 2156 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2157 : 		{	// promote left node to root of subtree
; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2164 : 
; 2165 : 		if (_Wherenode == _Root())
; 2166 : 			_Root() = _Pnode;
; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2169 : 		else
; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;
; 2173 : 		this->_Parent(_Wherenode) = _Pnode;
; 2174 : 		}
; 2175 : 
; 2176 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2177 : 		{	// find leftmost node greater than _Keyval
; 2178 : 		_Nodeptr _Pnode = _Root();
; 2179 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2180 : 
; 2181 : 		while (!this->_Isnil(_Pnode))
; 2182 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2183 : 				{	// _Pnode greater than _Keyval, remember it
; 2184 : 				_Wherenode = _Pnode;
; 2185 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2186 : 				}
; 2187 : 			else
; 2188 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2189 : 
; 2190 : 		return (_Wherenode);	// return best remembered candidate
; 2191 : 		}
; 2192 : 
; 2193 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2194 : 		{	// find leftmost node greater than _Keyval
; 2195 : 		_Nodeptr _Pnode = _Root();
; 2196 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2197 : 
; 2198 : 		while (!this->_Isnil(_Pnode))
; 2199 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2200 : 				{	// _Pnode greater than _Keyval, remember it
; 2201 : 				_Wherenode = _Pnode;
; 2202 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2203 : 				}
; 2204 : 			else
; 2205 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2206 : 
; 2207 : 		return (_Wherenode);	// return best remembered candidate
; 2208 : 		}
; 2209 : 
; 2210 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2211 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2212 : 		{	// orphan iterators with specified node pointers
; 2213 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2214 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2215 : 		if (_Pnext != 0)
; 2216 : 			while (*_Pnext != 0)
; 2217 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2218 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2219 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2220 : 				else
; 2221 : 					{	// orphan the iterator
; 2222 : 					(*_Pnext)->_Clrcont();
; 2223 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2224 : 					}
; 2225 : 		}
; 2226 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2227 : 
; 2228 : 	void _Tidy()
; 2229 : 		{	// free all storage
; 2230 : 		erase(begin(), end());

	lea	rdx, QWORD PTR $T5[rsp]
	mov	r9, r8
	mov	r8, QWORD PTR [r8]
	lea	rcx, OFFSET FLAT:?verbosity_filters@@3Vstr_container@@A+8
	call	?erase@?$_Tree@V?$_Tset_traits@PEAUstr_value@@Ustr_value_cmp@@V?$xalloc@PEAUstr_value@@@@$00@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PEAUstr_value@@@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<str_value * __ptr64,str_value_cmp,xalloc<str_value * __ptr64>,1> >::erase

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 520  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 521  : 
; 522  : 
; 523  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 524  : 		_Voidptr;
; 525  : 	typedef _Tree_node<typename _Alty::value_type,
; 526  : 		_Voidptr> _Node;
; 527  : 
; 528  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 529  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 530  : 	typedef _Nodeptr& _Nodepref;
; 531  : 
; 532  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 533  : 		_Tree_simple_types<typename _Alty::value_type>,
; 534  : 		_Tree_iter_types<typename _Alty::value_type,
; 535  : 			typename _Alty::size_type,
; 536  : 			typename _Alty::difference_type,
; 537  : 			typename _Alty::pointer,
; 538  : 			typename _Alty::const_pointer,
; 539  : 			typename _Alty::reference,
; 540  : 			typename _Alty::const_reference,
; 541  : 			_Nodeptr> >::type
; 542  : 		_Val_types;
; 543  : 	};
; 544  : 
; 545  : 		// TEMPLATE CLASS _Tree_val
; 546  : template<class _Val_types>
; 547  : 	class _Tree_val
; 548  : 		: public _Container_base
; 549  : 	{	// base class for tree to hold data
; 550  : public:
; 551  : 	typedef _Tree_val<_Val_types> _Myt;
; 552  : 
; 553  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 554  : 	typedef _Nodeptr& _Nodepref;
; 555  : 
; 556  : 	typedef typename _Val_types::value_type value_type;
; 557  : 	typedef typename _Val_types::size_type size_type;
; 558  : 	typedef typename _Val_types::difference_type difference_type;
; 559  : 	typedef typename _Val_types::pointer pointer;
; 560  : 	typedef typename _Val_types::const_pointer const_pointer;
; 561  : 	typedef typename _Val_types::reference reference;
; 562  : 	typedef typename _Val_types::const_reference const_reference;
; 563  : 
; 564  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 565  : 	typedef _Tree_iterator<_Myt> iterator;
; 566  : 
; 567  : 	_Tree_val()
; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;
; 570  : 		this->_Mysize = 0;
; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();
; 774  : 		}
; 775  : 
; 776  : 	~_Tree_alloc() _NOEXCEPT
; 777  : 		{	// destroy head node
; 778  : 		_Freeheadnode(this->_Myhead);

	mov	rbx, QWORD PTR ?verbosity_filters@@3Vstr_container@@A+8

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

	lea	rcx, QWORD PTR $T4[rsp]
	call	??0?$_Wrap_alloc@V?$xalloc@U?$_Tree_node@PEAUstr_value@@PEAX@std@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >

; 779  : 		}
; 780  : 
; 781  : 	void _Change_alloc(const _Alty&)
; 782  : 		{	// replace old allocator
; 783  : 		}
; 784  : 
; 785  : 	void _Swap_alloc(_Myt&)
; 786  : 		{	// swap allocators
; 787  : 		}
; 788  : 
; 789  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 790  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 791  : 		{	// construct allocators from _Al
; 792  : 		this->_Myhead = _Buyheadnode();
; 793  : 		_TRY_BEGIN
; 794  : 		_Alloc_proxy();
; 795  : 		_CATCH_ALL
; 796  : 		_Freeheadnode(this->_Myhead);
; 797  : 		_RERAISE;
; 798  : 		_CATCH_END
; 799  : 		}
; 800  : 
; 801  : 	~_Tree_alloc() _NOEXCEPT
; 802  : 		{	// destroy proxy
; 803  : 		_Freeheadnode(this->_Myhead);
; 804  : 		_Free_proxy();
; 805  : 		}
; 806  : 
; 807  : 	void _Change_alloc(const _Alty&)
; 808  : 		{	// replace old allocator
; 809  : 		}
; 810  : 
; 811  : 	void _Swap_alloc(_Myt&)
; 812  : 		{	// swap allocators
; 813  : 		}
; 814  : 
; 815  : 	void _Alloc_proxy()
; 816  : 		{	// construct proxy from _Alnod
; 817  : 		typename _Alty::template rebind<_Container_proxy>::other
; 818  : 			_Alproxy(_Getal());
; 819  : 		this->_Myproxy = _Alproxy.allocate(1);
; 820  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 821  : 		this->_Myproxy->_Mycont = this;
; 822  : 		}
; 823  : 
; 824  : 	void _Free_proxy()
; 825  : 		{	// destroy proxy
; 826  : 		typename _Alty::template rebind<_Container_proxy>::other
; 827  : 			_Alproxy(_Getal());
; 828  : 		this->_Orphan_all();
; 829  : 		_Alproxy.destroy(this->_Myproxy);
; 830  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 831  : 		this->_Myproxy = 0;
; 832  : 		}
; 833  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 834  : 
; 835  : 	_Nodeptr _Buyheadnode()
; 836  : 		{	// get head node using current allocator
; 837  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 838  : 
; 839  : 		_TRY_BEGIN
; 840  : 		this->_Getal().construct(
; 841  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 842  : 		this->_Getal().construct(
; 843  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 844  : 		this->_Getal().construct(
; 845  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 846  : 		_CATCH_ALL
; 847  : 		this->_Getal().deallocate(_Pnode, 1);
; 848  : 		_RERAISE;
; 849  : 		_CATCH_END
; 850  : 
; 851  : 		this->_Color(_Pnode) = this->_Black;
; 852  : 		this->_Isnil(_Pnode) = true;
; 853  : 		return (_Pnode);
; 854  : 		}
; 855  : 
; 856  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 857  : 		{	// free head node using current allocator
; 858  : 		this->_Getal().destroy(
; 859  : 			_STD addressof(this->_Left(_Pnode)));

	call	??$destroy@PEAU?$_Tree_node@PEAUstr_value@@PEAX@std@@@?$_Wrap_alloc@V?$xalloc@U?$_Tree_node@PEAUstr_value@@PEAX@std@@@@@std@@QEAAXPEAPEAU?$_Tree_node@PEAUstr_value@@PEAX@1@@Z ; std::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >::destroy<std::_Tree_node<str_value * __ptr64,void * __ptr64> * __ptr64>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$_Wrap_alloc@V?$xalloc@U?$_Tree_node@PEAUstr_value@@PEAX@std@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >

; 860  : 		this->_Getal().destroy(
; 861  : 			_STD addressof(this->_Parent(_Pnode)));

	call	??$destroy@PEAU?$_Tree_node@PEAUstr_value@@PEAX@std@@@?$_Wrap_alloc@V?$xalloc@U?$_Tree_node@PEAUstr_value@@PEAX@std@@@@@std@@QEAAXPEAPEAU?$_Tree_node@PEAUstr_value@@PEAX@1@@Z ; std::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >::destroy<std::_Tree_node<str_value * __ptr64,void * __ptr64> * __ptr64>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$_Wrap_alloc@V?$xalloc@U?$_Tree_node@PEAUstr_value@@PEAX@std@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >

; 862  : 		this->_Getal().destroy(
; 863  : 			_STD addressof(this->_Right(_Pnode)));

	call	??$destroy@PEAU?$_Tree_node@PEAUstr_value@@PEAX@std@@@?$_Wrap_alloc@V?$xalloc@U?$_Tree_node@PEAUstr_value@@PEAX@std@@@@@std@@QEAAXPEAPEAU?$_Tree_node@PEAUstr_value@@PEAX@1@@Z ; std::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >::destroy<std::_Tree_node<str_value * __ptr64,void * __ptr64> * __ptr64>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);
; 865  : 		}
; 866  : 
; 867  : 	_Alty _Getal() const
; 868  : 		{	// get allocator
; 869  : 		return (_Alty());

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$_Wrap_alloc@V?$xalloc@U?$_Tree_node@PEAUstr_value@@PEAX@std@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >::_Wrap_alloc<xalloc<std::_Tree_node<str_value * __ptr64,void * __ptr64> > >
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$6[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$6[rsp], rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	call	??$xr_free@U?$_Tree_node@PEAUstr_value@@PEAX@std@@@@YAXAEAPEAU?$_Tree_node@PEAUstr_value@@PEAX@std@@@Z ; xr_free<std::_Tree_node<str_value * __ptr64,void * __ptr64> >
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 46   : 	DeleteCriticalSection			( (CRITICAL_SECTION*)pmutex	);

	mov	rcx, QWORD PTR ?verbosity_filters@@3Vstr_container@@A
	call	QWORD PTR __imp_DeleteCriticalSection

; 47   : 	xr_free							( pmutex		);

	lea	rcx, OFFSET FLAT:?verbosity_filters@@3Vstr_container@@A ; verbosity_filters
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
??__Fverbosity_filters@@YAXXZ ENDP			; `dynamic atexit destructor for 'verbosity_filters''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
;	COMDAT ??__ElogCS@@YAXXZ
text$di	SEGMENT
??__ElogCS@@YAXXZ PROC					; `dynamic initializer for 'logCS'', COMDAT

; 22   : 	static xrCriticalSection	logCS;

	sub	rsp, 40					; 00000028H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 40					; 00000028H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 41   : 	InitializeCriticalSection		( (CRITICAL_SECTION*)pmutex	);

	mov	rcx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	QWORD PTR logCS, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 41   : 	InitializeCriticalSection		( (CRITICAL_SECTION*)pmutex	);

	call	QWORD PTR __imp_InitializeCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp

; 22   : 	static xrCriticalSection	logCS;

	lea	rcx, OFFSET FLAT:??__FlogCS@@YAXXZ	; `dynamic atexit destructor for 'logCS''
	add	rsp, 40					; 00000028H
	jmp	atexit
??__ElogCS@@YAXXZ ENDP					; `dynamic initializer for 'logCS''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
;	COMDAT ??__FlogCS@@YAXXZ
text$yd	SEGMENT
??__FlogCS@@YAXXZ PROC					; `dynamic atexit destructor for 'logCS'', COMDAT
	sub	rsp, 40					; 00000028H

; 46   : 	DeleteCriticalSection			( (CRITICAL_SECTION*)pmutex	);

	mov	rcx, QWORD PTR logCS
	call	QWORD PTR __imp_DeleteCriticalSection

; 47   : 	xr_free							( pmutex		);

	lea	rcx, OFFSET FLAT:logCS
	add	rsp, 40					; 00000028H
	jmp	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
??__FlogCS@@YAXXZ ENDP					; `dynamic atexit destructor for 'logCS''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
file_name$dead$ = 48
?FlushLog@@YAXPEBD@Z PROC				; FlushLog

; 32   : {

$LN6:
	sub	rsp, 40					; 00000028H

; 33   : 	if (LogWriter)

	mov	rcx, QWORD PTR ?LogWriter@@3PEAVIWriter@@EA ; LogWriter
	test	rcx, rcx
	je	SHORT $LN4@FlushLog

; 34   : 		LogWriter->flush();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+40]
$LN4@FlushLog:

; 35   : 	cached_log = 0;

	mov	QWORD PTR ?cached_log@@3_KA, 0		; cached_log

; 36   : }

	add	rsp, 40					; 00000028H
	ret	0
?FlushLog@@YAXPEBD@Z ENDP				; FlushLog
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
?FlushLog@@YAXXZ PROC					; FlushLog

; 39   : {

$LN8:
	sub	rsp, 40					; 00000028H

; 33   : 	if (LogWriter)

	mov	rcx, QWORD PTR ?LogWriter@@3PEAVIWriter@@EA ; LogWriter
	test	rcx, rcx
	je	SHORT $LN6@FlushLog

; 34   : 		LogWriter->flush();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+40]
$LN6@FlushLog:

; 35   : 	cached_log = 0;

	mov	QWORD PTR ?cached_log@@3_KA, 0		; cached_log

; 40   : 	FlushLog		(logFName);
; 41   : }

	add	rsp, 40					; 00000028H
	ret	0
?FlushLog@@YAXXZ ENDP					; FlushLog
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
t$ = 32
tv80 = 40
tmp$ = 48
filters$ = 4160
?InitVerbosity@@YAXPEBD@Z PROC				; InitVerbosity

; 46   : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 4152				; 00001038H
	call	__chkstk
	sub	rsp, rax

; 47   : 	string4096 tmp;
; 48   : 	strcpy_s(tmp, 4095, filters);

	mov	r8, QWORD PTR filters$[rsp]
	mov	edx, 4095				; 00000fffH
	lea	rcx, QWORD PTR tmp$[rsp]
	call	QWORD PTR __imp_strcpy_s

; 49   : 	tmp[sizeof(tmp) - 1] = 0;

	mov	eax, 1
	imul	rax, rax, 4095				; 00000fffH
	mov	BYTE PTR tmp$[rsp+rax], 0

; 50   : 	char *t = strtok(tmp, ",");

	lea	rdx, OFFSET FLAT:??_C@_01IHBHIGKO@?0?$AA@
	lea	rcx, QWORD PTR tmp$[rsp]
	call	QWORD PTR __imp_strtok
	mov	QWORD PTR t$[rsp], rax
$LN3@InitVerbos:

; 51   : 	while (NULL != t)

	cmp	QWORD PTR t$[rsp], 0
	je	SHORT $LN2@InitVerbos

; 52   : 	{
; 53   : 		if (xr_strlen(t) > 0)

	mov	rcx, QWORD PTR t$[rsp]
	call	?xr_strlen@@YAIPEBD@Z			; xr_strlen
	test	eax, eax
	jbe	SHORT $LN1@InitVerbos

; 54   : 			verbosity_filters.dock(t)->dwReference++;

	mov	rdx, QWORD PTR t$[rsp]
	lea	rcx, OFFSET FLAT:?verbosity_filters@@3Vstr_container@@A ; verbosity_filters
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR tv80[rsp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR tv80[rsp]
	mov	DWORD PTR [rcx], eax
$LN1@InitVerbos:

; 55   : 		t = strtok(NULL, ",");

	lea	rdx, OFFSET FLAT:??_C@_01IHBHIGKO@?0?$AA@
	xor	ecx, ecx
	call	QWORD PTR __imp_strtok
	mov	QWORD PTR t$[rsp], rax

; 56   : 	}

	jmp	SHORT $LN3@InitVerbos
$LN2@InitVerbos:

; 57   : 
; 58   : }

	add	rsp, 4152				; 00001038H
	ret	0
?InitVerbosity@@YAXPEBD@Z ENDP				; InitVerbosity
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
tv83 = 80
tv128 = 84
lt$1 = 88
tv92 = 104
temp$2 = 112
buf$3 = 128
split$ = 208
?AddOne@@YAXPEBD@Z PROC					; AddOne

; 64   : {

$LN31:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 65   : 	if(!LogFile)		

	cmp	QWORD PTR ?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA, 0 ; LogFile
	jne	SHORT $LN9@AddOne

; 66   : 						return;

	jmp	$LN10@AddOne
$LN9@AddOne:

; 67   : 
; 68   : 	logCS.Enter			();

	lea	rcx, OFFSET FLAT:logCS
	call	?Enter@xrCriticalSection@@QEAAXXZ	; xrCriticalSection::Enter

; 69   : 
; 70   : #ifdef DEBUG
; 71   : 	OutputDebugString	(split);
; 72   : 	OutputDebugString	("\n");
; 73   : #endif
; 74   : 
; 75   : 	//exec CallBack
; 76   : 	if (LogExecCB&&LogCB)LogCB(split);

	cmp	DWORD PTR ?LogExecCB@@3HA, 0		; LogExecCB
	je	SHORT $LN8@AddOne
	cmp	QWORD PTR LogCB, 0
	je	SHORT $LN8@AddOne
	mov	rcx, QWORD PTR split$[rsp]
	call	QWORD PTR LogCB
$LN8@AddOne:

; 77   : 
; 78   : //	DUMP_PHASE;
; 79   : 	{
; 80   : 		if (shared_str_initialized)

	movzx	eax, BYTE PTR ?shared_str_initialized@@3_NA ; shared_str_initialized
	test	eax, eax
	je	SHORT $LN7@AddOne

; 81   : 		{
; 82   : 			shared_str			temp = shared_str(split);

	mov	rdx, QWORD PTR split$[rsp]
	lea	rcx, QWORD PTR temp$2[rsp]
	call	??0shared_str@@QEAA@PEBD@Z		; shared_str::shared_str

; 83   : 			LogFile->push_back(temp);

	lea	rdx, QWORD PTR temp$2[rsp]
	mov	rcx, QWORD PTR ?LogFile@@3PEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@EA ; LogFile
	call	?push_back@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAXAEBVshared_str@@@Z ; std::vector<shared_str,xalloc<shared_str> >::push_back

; 84   : 		}

	lea	rcx, QWORD PTR temp$2[rsp]
	call	??1shared_str@@QEAA@XZ			; shared_str::~shared_str
$LN7@AddOne:

; 85   : 
; 86   : 		//+RvP, alpet
; 87   : 		if (LogWriter)

	cmp	QWORD PTR ?LogWriter@@3PEAVIWriter@@EA, 0 ; LogWriter
	je	$LN6@AddOne

; 88   : 		{				
; 89   : 			switch (*split)

	mov	rax, QWORD PTR split$[rsp]
	mov	al, BYTE PTR [rax]
	mov	BYTE PTR tv83[rsp], al
	cmp	BYTE PTR tv83[rsp], 33			; 00000021H
	je	SHORT $LN3@AddOne
	cmp	BYTE PTR tv83[rsp], 35			; 00000023H
	je	SHORT $LN3@AddOne
	cmp	BYTE PTR tv83[rsp], 37			; 00000025H
	je	SHORT $LN3@AddOne
	jmp	SHORT $LN4@AddOne
$LN3@AddOne:

; 90   : 			{
; 91   : 			case 0x21:
; 92   : 			case 0x23:
; 93   : 			case 0x25:
; 94   : 				split ++; // пропустить первый символ, т.к. это веро€тно цветовой тег

	mov	rax, QWORD PTR split$[rsp]
	inc	rax
	mov	QWORD PTR split$[rsp], rax
$LN4@AddOne:

; 95   : 				break;
; 96   : 			}
; 97   : 
; 98   : 			char buf[64];
; 99   : #ifdef	LOG_TIME_PRECISE 
; 100  : 			SYSTEMTIME lt;
; 101  : 			GetLocalTime(&lt);

	lea	rcx, QWORD PTR lt$1[rsp]
	call	QWORD PTR __imp_GetLocalTime

; 102  : 			
; 103  : 			sprintf_s(buf, 64, "[%02d.%02d.%02d %02d:%02d:%02d.%03d] ", lt.wDay, lt.wMonth, lt.wYear % 100, lt.wHour, lt.wMinute, lt.wSecond, lt.wMilliseconds);						

	movzx	eax, WORD PTR lt$1[rsp+14]
	mov	DWORD PTR tv92[rsp], eax
	movzx	ecx, WORD PTR lt$1[rsp+12]
	movzx	edx, WORD PTR lt$1[rsp+10]
	mov	DWORD PTR tv128[rsp], edx
	movzx	r8d, WORD PTR lt$1[rsp+8]
	movzx	r9d, WORD PTR lt$1[rsp]
	mov	eax, r9d
	cdq
	mov	r9d, 100				; 00000064H
	idiv	r9d
	mov	eax, edx
	movzx	edx, WORD PTR lt$1[rsp+2]
	movzx	r9d, WORD PTR lt$1[rsp+6]
	mov	r10d, DWORD PTR tv92[rsp]
	mov	DWORD PTR [rsp+72], r10d
	mov	DWORD PTR [rsp+64], ecx
	mov	ecx, DWORD PTR tv128[rsp]
	mov	DWORD PTR [rsp+56], ecx
	mov	DWORD PTR [rsp+48], r8d
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], edx
	lea	r8, OFFSET FLAT:??_C@_0CG@DOMCHCAE@?$FL?$CF02d?4?$CF02d?4?$CF02d?5?$CF02d?3?$CF02d?3?$CF02d?4?$CF@
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR buf$3[rsp]
	call	QWORD PTR __imp_sprintf_s

; 104  : 			LogWriter->w_printf("%s%s\r\n", buf, split);

	mov	r9, QWORD PTR split$[rsp]
	lea	r8, QWORD PTR buf$3[rsp]
	lea	rdx, OFFSET FLAT:??_C@_06PADMJNAK@?$CFs?$CFs?$AN?6?$AA@
	mov	rcx, QWORD PTR ?LogWriter@@3PEAVIWriter@@EA ; LogWriter
	call	?w_printf@IWriter@@QEAAXPEBDZZ		; IWriter::w_printf

; 105  : 			cached_log += xr_strlen(buf);

	lea	rcx, QWORD PTR buf$3[rsp]
	call	?xr_strlen@@YAIPEBD@Z			; xr_strlen
	mov	eax, eax
	mov	rcx, QWORD PTR ?cached_log@@3_KA	; cached_log
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?cached_log@@3_KA, rax	; cached_log

; 106  : 			cached_log += xr_strlen(split) + 2;

	mov	rcx, QWORD PTR split$[rsp]
	call	?xr_strlen@@YAIPEBD@Z			; xr_strlen
	add	eax, 2
	mov	eax, eax
	mov	rcx, QWORD PTR ?cached_log@@3_KA	; cached_log
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?cached_log@@3_KA, rax	; cached_log

; 107  : #else
; 108  : 			time_t t = time(NULL);
; 109  : 			tm* ti = localtime(&t);
; 110  : 			
; 111  : 			strftime(buf, 64, "[%x %X]\t", ti);
; 112  : 
; 113  : 			LogWriter->wprintf("%s %s\r\n", buf, split);
; 114  : #endif
; 115  : 			if (force_flush_log || cached_log >= 32768)

	movzx	eax, BYTE PTR ?force_flush_log@@3_NA	; force_flush_log
	test	eax, eax
	jne	SHORT $LN1@AddOne
	cmp	QWORD PTR ?cached_log@@3_KA, 32768	; cached_log, 00008000H
	jb	SHORT $LN6@AddOne
$LN1@AddOne:

; 116  : 				FlushLog();

	call	?FlushLog@@YAXXZ			; FlushLog
$LN6@AddOne:

; 117  : 		}
; 118  : 		//-RvP
; 119  : 	}
; 120  : 
; 121  : 
; 122  : 	logCS.Leave				();

	lea	rcx, OFFSET FLAT:logCS
	call	?Leave@xrCriticalSection@@QEAAXXZ	; xrCriticalSection::Leave
$LN10@AddOne:

; 123  : }

	add	rsp, 200				; 000000c8H
	ret	0
?AddOne@@YAXPEBD@Z ENDP					; AddOne
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
sz$ = 32
buf$ = 48
format$ = 4160
mark$ = 4168
?LogVAList@@YAXPEBDAEAPEAD@Z PROC			; LogVAList

; 146  : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	eax, 4152				; 00001038H
	call	__chkstk
	sub	rsp, rax

; 147  : 	string4096	buf; // alpet: размер буфера лучше сделать побольше, чтобы избежать вылетов invalid parameter handler при выводе стеков вызова
; 148  : 	int sz		= _vsnprintf(buf, sizeof(buf)-1, format, mark); buf[sizeof(buf)-1]=0;

	mov	rax, QWORD PTR mark$[rsp]
	mov	r9, QWORD PTR [rax]
	mov	r8, QWORD PTR format$[rsp]
	mov	edx, 4095				; 00000fffH
	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp__vsnprintf
	mov	DWORD PTR sz$[rsp], eax
	mov	eax, 1
	imul	rax, rax, 4095				; 00000fffH
	mov	BYTE PTR buf$[rsp+rax], 0

; 149  :     va_end		(mark);

	mov	rax, QWORD PTR mark$[rsp]
	mov	QWORD PTR [rax], 0

; 150  : 	if (sz)		Log(buf);

	cmp	DWORD PTR sz$[rsp], 0
	je	SHORT $LN1@LogVAList
	lea	rcx, QWORD PTR buf$[rsp]
	call	?Log@@YAXPEBD@Z				; Log
$LN1@LogVAList:

; 151  : }

	add	rsp, 4152				; 00001038H
	ret	0
?LogVAList@@YAXPEBDAEAPEAD@Z ENDP			; LogVAList
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
i$1 = 64
sz$ = 68
mark$ = 72
lt$2 = 80
dest$3 = 96
buf$ = 112
format$ = 4224
?MsgCB@@YAXPEBDZZ PROC					; MsgCB

; 161  : {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	mov	eax, 4216				; 00001078H
	call	__chkstk
	sub	rsp, rax

; 162  : 	static string4096 ctx_ring[16];   // кольцевой буфер дл€ сохранени€ данных контекста выполнени€ (выводитс€ при сбое, или по необходимости)
; 163  : 	static u32 ctx_index = 0;
; 164  : 
; 165  : 	va_list mark;
; 166  : 	string4096	buf;
; 167  : 	va_start(mark, format);

	lea	rax, QWORD PTR format$[rsp+8]
	mov	QWORD PTR mark$[rsp], rax

; 168  : 	int sz = _vsnprintf(buf, sizeof(buf)-1, format, mark); buf[sizeof(buf)-1] = 0;

	mov	r9, QWORD PTR mark$[rsp]
	mov	r8, QWORD PTR format$[rsp]
	mov	edx, 4095				; 00000fffH
	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp__vsnprintf
	mov	DWORD PTR sz$[rsp], eax
	mov	eax, 1
	imul	rax, rax, 4095				; 00000fffH
	mov	BYTE PTR buf$[rsp+rax], 0

; 169  : 	va_end(mark);

	mov	QWORD PTR mark$[rsp], 0

; 170  : 	// функци€ двойного назначени€: может использоватьс€ дл€ вотчинга произвольных переменных в местах потенциальных сбоев
; 171  : 	if (strstr(buf, "#CONTEXT:"))

	lea	rdx, OFFSET FLAT:??_C@_09PMCACMHN@?$CDCONTEXT?3?$AA@
	lea	rcx, QWORD PTR buf$[rsp]
	call	?strstr@@YAPEADPEADPEBD@Z		; strstr
	test	rax, rax
	je	$LN6@MsgCB

; 172  : 	{
; 173  : 		SYSTEMTIME lt;
; 174  : 		GetLocalTime(&lt);

	lea	rcx, QWORD PTR lt$2[rsp]
	call	QWORD PTR __imp_GetLocalTime

; 175  : 		LPSTR dest = ctx_ring[ctx_index & 15];

	mov	eax, DWORD PTR ?ctx_index@?1??MsgCB@@YAXPEBDZZ@4IA
	and	eax, 15
	mov	eax, eax
	imul	rax, rax, 4096				; 00001000H
	lea	rcx, OFFSET FLAT:?ctx_ring@?1??MsgCB@@YAXPEBDZZ@4PAY0BAAA@DA
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dest$3[rsp], rax

; 176  : 		ctx_index++;

	mov	eax, DWORD PTR ?ctx_index@?1??MsgCB@@YAXPEBDZZ@4IA
	inc	eax
	mov	DWORD PTR ?ctx_index@?1??MsgCB@@YAXPEBDZZ@4IA, eax

; 177  : 		// copy-paste forever	
; 178  : 		sprintf_s(dest, sizeof(buf) - 1, "[%02d:%02d:%02d.%03d]. %s", lt.wHour, lt.wMinute, lt.wSecond, lt.wMilliseconds, buf);						

	movzx	eax, WORD PTR lt$2[rsp+14]
	movzx	ecx, WORD PTR lt$2[rsp+12]
	movzx	edx, WORD PTR lt$2[rsp+10]
	movzx	r8d, WORD PTR lt$2[rsp+8]
	lea	r9, QWORD PTR buf$[rsp]
	mov	QWORD PTR [rsp+56], r9
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ecx
	mov	DWORD PTR [rsp+32], edx
	mov	r9d, r8d
	lea	r8, OFFSET FLAT:??_C@_0BK@EDFKPBBE@?$FL?$CF02d?3?$CF02d?3?$CF02d?4?$CF03d?$FN?4?5?$CFs?$AA@
	mov	edx, 4095				; 00000fffH
	mov	rcx, QWORD PTR dest$3[rsp]
	call	QWORD PTR __imp_sprintf_s

; 179  : 		return;

	jmp	$LN7@MsgCB
$LN6@MsgCB:

; 180  : 	}
; 181  : 	if (strstr(buf, "#DUMP_CONTEXT"))

	lea	rdx, OFFSET FLAT:??_C@_0O@LCKMNMMD@?$CDDUMP_CONTEXT?$AA@
	lea	rcx, QWORD PTR buf$[rsp]
	call	?strstr@@YAPEADPEADPEBD@Z		; strstr
	test	rax, rax
	je	SHORT $LN5@MsgCB

; 182  : 	{
; 183  : 		Log("#DEBUG CONTEXT DUMP:");

	lea	rcx, OFFSET FLAT:??_C@_0BF@FNJBEDFL@?$CDDEBUG?5CONTEXT?5DUMP?3?$AA@
	call	?Log@@YAXPEBD@Z				; Log

; 184  : 		for (u32 i = 15; i > 0; i--)

	mov	DWORD PTR i$1[rsp], 15
	jmp	SHORT $LN4@MsgCB
$LN3@MsgCB:
	mov	eax, DWORD PTR i$1[rsp]
	dec	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@MsgCB:
	cmp	DWORD PTR i$1[rsp], 0
	jbe	SHORT $LN2@MsgCB

; 185  : 			Msg("# %s", ctx_ring[(ctx_index + i) & 15]);

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR ?ctx_index@?1??MsgCB@@YAXPEBDZZ@4IA
	add	ecx, eax
	mov	eax, ecx
	and	eax, 15
	mov	eax, eax
	imul	rax, rax, 4096				; 00001000H
	lea	rcx, OFFSET FLAT:?ctx_ring@?1??MsgCB@@YAXPEBDZZ@4PAY0BAAA@DA
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_04CFBKFMDG@?$CD?5?$CFs?$AA@
	call	?Msg@@YAXPEBDZZ				; Msg
	jmp	SHORT $LN3@MsgCB
$LN2@MsgCB:

; 186  : 
; 187  : 		return;

	jmp	SHORT $LN7@MsgCB
$LN5@MsgCB:

; 188  : 	}
; 189  : 
; 190  : 	if (NULL != LogCB && sz)		LogCB(buf);

	cmp	QWORD PTR LogCB, 0
	je	SHORT $LN1@MsgCB
	cmp	DWORD PTR sz$[rsp], 0
	je	SHORT $LN1@MsgCB
	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR LogCB
$LN1@MsgCB:
$LN7@MsgCB:

; 191  : }

	add	rsp, 4216				; 00001078H
	ret	0
?MsgCB@@YAXPEBDZZ ENDP					; MsgCB
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
b_show$ = 32
tv69 = 36
tv93 = 40
msg_level$1 = 44
f$ = 48
mark$2 = 56
verbosity$ = 80
format$ = 88
?MsgV@@YAXPEBD0ZZ PROC					; MsgV

; 195  : {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 72					; 00000048H

; 196  : 	if (!verbosity) return;	

	cmp	QWORD PTR verbosity$[rsp], 0
	jne	SHORT $LN5@MsgV
	jmp	$LN6@MsgV
$LN5@MsgV:

; 197  : 	bool b_show = (verbosity[0] != '!');

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR verbosity$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 33					; 00000021H
	je	SHORT $LN8@MsgV
	mov	DWORD PTR tv69[rsp], 1
	jmp	SHORT $LN9@MsgV
$LN8@MsgV:
	mov	DWORD PTR tv69[rsp], 0
$LN9@MsgV:
	mov	al, BYTE PTR tv69[rsp]
	mov	BYTE PTR b_show$[rsp], al

; 198  : 	if (!b_show)

	movzx	eax, BYTE PTR b_show$[rsp]
	test	eax, eax
	jne	SHORT $LN4@MsgV

; 199  : 		verbosity++;

	mov	rax, QWORD PTR verbosity$[rsp]
	inc	rax
	mov	QWORD PTR verbosity$[rsp], rax
$LN4@MsgV:

; 200  : 
; 201  : 	if (verbosity[0] >= '0' && verbosity[0] <= '9')

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR verbosity$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN3@MsgV
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR verbosity$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN3@MsgV

; 202  : 	{
; 203  : 		u32 msg_level = verbosity[0] - '0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR verbosity$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR msg_level$1[rsp], eax

; 204  : 		if (msg_level > verbosity_level) return;

	mov	eax, DWORD PTR ?verbosity_level@@3IA	; verbosity_level
	cmp	DWORD PTR msg_level$1[rsp], eax
	jbe	SHORT $LN2@MsgV
	jmp	SHORT $LN6@MsgV
$LN2@MsgV:

; 205  : 		verbosity++;

	mov	rax, QWORD PTR verbosity$[rsp]
	inc	rax
	mov	QWORD PTR verbosity$[rsp], rax
$LN3@MsgV:

; 206  : 	}
; 207  : 	str_value *f = verbosity_filters.dock(verbosity);

	mov	rdx, QWORD PTR verbosity$[rsp]
	lea	rcx, OFFSET FLAT:?verbosity_filters@@3Vstr_container@@A ; verbosity_filters
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	QWORD PTR f$[rsp], rax

; 208  : 	if ( (f->dwReference > 0) == b_show )

	mov	rax, QWORD PTR f$[rsp]
	cmp	DWORD PTR [rax], 0
	jbe	SHORT $LN10@MsgV
	mov	DWORD PTR tv93[rsp], 1
	jmp	SHORT $LN11@MsgV
$LN10@MsgV:
	mov	DWORD PTR tv93[rsp], 0
$LN11@MsgV:
	movzx	eax, BYTE PTR b_show$[rsp]
	cmp	DWORD PTR tv93[rsp], eax
	jne	SHORT $LN1@MsgV

; 209  : 	{		
; 210  : 		va_list mark;
; 211  : 		va_start(mark, format);		

	lea	rax, QWORD PTR format$[rsp+8]
	mov	QWORD PTR mark$2[rsp], rax

; 212  : 		LogVAList (format, mark);

	lea	rdx, QWORD PTR mark$2[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	call	?LogVAList@@YAXPEBDAEAPEAD@Z		; LogVAList
$LN1@MsgV:
$LN6@MsgV:

; 213  : 	}
; 214  : 	// f->dwReference--;
; 215  : }

	add	rsp, 72					; 00000048H
	ret	0
?MsgV@@YAXPEBD0ZZ ENDP					; MsgV
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
buf$ = 48
msg$ = 1088
dop$ = 1096
?Log@@YAXPEBDH@Z PROC					; Log

; 233  : void Log				(const char *msg, int dop) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1080				; 00000438H

; 234  : 	char buf[1024];
; 235  : 
; 236  : 	sprintf_s	(buf, sizeof(buf),"%s %d",msg,dop);

	mov	eax, DWORD PTR dop$[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR msg$[rsp]
	lea	r8, OFFSET FLAT:??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp_sprintf_s

; 237  : 	Log		(buf);

	lea	rcx, QWORD PTR buf$[rsp]
	call	?Log@@YAXPEBD@Z				; Log

; 238  : }

	add	rsp, 1080				; 00000438H
	ret	0
?Log@@YAXPEBDH@Z ENDP					; Log
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
buf$ = 48
msg$ = 1088
dop$ = 1096
?Log@@YAXPEBDM@Z PROC					; Log

; 240  : void Log				(const char *msg, float dop) {

$LN3:
	movss	DWORD PTR [rsp+16], xmm1
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1080				; 00000438H

; 241  : 	char buf[1024];
; 242  : 
; 243  : 	sprintf_s	(buf, sizeof(buf),"%s %f",msg,dop);

	cvtss2sd xmm0, DWORD PTR dop$[rsp]
	movsdx	QWORD PTR [rsp+32], xmm0
	mov	r9, QWORD PTR msg$[rsp]
	lea	r8, OFFSET FLAT:??_C@_05KDNLHNC@?$CFs?5?$CFf?$AA@
	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp_sprintf_s

; 244  : 	Log		(buf);

	lea	rcx, QWORD PTR buf$[rsp]
	call	?Log@@YAXPEBD@Z				; Log

; 245  : }

	add	rsp, 1080				; 00000438H
	ret	0
?Log@@YAXPEBDM@Z ENDP					; Log
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
buf$ = 64
msg$ = 1104
dop$ = 1112
?Log@@YAXPEBDAEBU?$_vector3@M@@@Z PROC			; Log

; 247  : void Log				(const char *msg, const Fvector &dop) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1096				; 00000448H

; 248  : 	char buf[1024];
; 249  : 
; 250  : 	sprintf_s	(buf,sizeof(buf),"%s (%f,%f,%f)",msg,dop.x,dop.y,dop.z);

	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+8]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm1, DWORD PTR [rax+4]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm2, DWORD PTR [rax]
	movsdx	QWORD PTR [rsp+48], xmm0
	movsdx	QWORD PTR [rsp+40], xmm1
	movsdx	QWORD PTR [rsp+32], xmm2
	mov	r9, QWORD PTR msg$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0O@LEOODNAC@?$CFs?5?$CI?$CFf?0?$CFf?0?$CFf?$CJ?$AA@
	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp_sprintf_s

; 251  : 	Log		(buf);

	lea	rcx, QWORD PTR buf$[rsp]
	call	?Log@@YAXPEBD@Z				; Log

; 252  : }

	add	rsp, 1096				; 00000448H
	ret	0
?Log@@YAXPEBDAEBU?$_vector3@M@@@Z ENDP			; Log
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
buf$ = 160
msg$ = 1360
dop$ = 1368
?Log@@YAXPEBDAEBU?$_matrix@M@@@Z PROC			; Log

; 254  : void Log				(const char *msg, const Fmatrix &dop)	{

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 1352				; 00000548H
	movaps	XMMWORD PTR [rsp+1328], xmm6
	movaps	XMMWORD PTR [rsp+1312], xmm7
	movaps	XMMWORD PTR [rsp+1296], xmm8
	movaps	XMMWORD PTR [rsp+1280], xmm9
	movaps	XMMWORD PTR [rsp+1264], xmm10
	movaps	XMMWORD PTR [rsp+1248], xmm11
	movaps	XMMWORD PTR [rsp+1232], xmm12
	movaps	XMMWORD PTR [rsp+1216], xmm13
	movaps	XMMWORD PTR [rsp+1200], xmm14
	movaps	XMMWORD PTR [rsp+1184], xmm15

; 255  : 	char	buf	[1024];
; 256  : 
; 257  : 	sprintf_s	(buf,sizeof(buf),"%s:\n%f,%f,%f,%f\n%f,%f,%f,%f\n%f,%f,%f,%f\n%f,%f,%f,%f\n",msg,dop.i.x,dop.i.y,dop.i.z,dop._14_
; 258  : 																				,dop.j.x,dop.j.y,dop.j.z,dop._24_
; 259  : 																				,dop.k.x,dop.k.y,dop.k.z,dop._34_
; 260  : 																				,dop.c.x,dop.c.y,dop.c.z,dop._44_);

	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm0, DWORD PTR [rax+60]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm1, DWORD PTR [rax+56]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm2, DWORD PTR [rax+52]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm3, DWORD PTR [rax+48]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm4, DWORD PTR [rax+44]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm5, DWORD PTR [rax+40]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm6, DWORD PTR [rax+36]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm7, DWORD PTR [rax+32]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm8, DWORD PTR [rax+28]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm9, DWORD PTR [rax+24]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm10, DWORD PTR [rax+20]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm11, DWORD PTR [rax+16]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm12, DWORD PTR [rax+12]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm13, DWORD PTR [rax+8]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm14, DWORD PTR [rax+4]
	mov	rax, QWORD PTR dop$[rsp]
	cvtss2sd xmm15, DWORD PTR [rax]
	movsdx	QWORD PTR [rsp+152], xmm0
	movsdx	QWORD PTR [rsp+144], xmm1
	movsdx	QWORD PTR [rsp+136], xmm2
	movsdx	QWORD PTR [rsp+128], xmm3
	movsdx	QWORD PTR [rsp+120], xmm4
	movsdx	QWORD PTR [rsp+112], xmm5
	movsdx	QWORD PTR [rsp+104], xmm6
	movsdx	QWORD PTR [rsp+96], xmm7
	movsdx	QWORD PTR [rsp+88], xmm8
	movsdx	QWORD PTR [rsp+80], xmm9
	movsdx	QWORD PTR [rsp+72], xmm10
	movsdx	QWORD PTR [rsp+64], xmm11
	movsdx	QWORD PTR [rsp+56], xmm12
	movsdx	QWORD PTR [rsp+48], xmm13
	movsdx	QWORD PTR [rsp+40], xmm14
	movsdx	QWORD PTR [rsp+32], xmm15
	mov	r9, QWORD PTR msg$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0DF@PAGJPMKE@?$CFs?3?6?$CFf?0?$CFf?0?$CFf?0?$CFf?6?$CFf?0?$CFf?0?$CFf?0?$CFf?6?$CFf?0?$CF@
	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp_sprintf_s

; 261  : 	Log		(buf);

	lea	rcx, QWORD PTR buf$[rsp]
	call	?Log@@YAXPEBD@Z				; Log

; 262  : }

	movaps	xmm6, XMMWORD PTR [rsp+1328]
	movaps	xmm7, XMMWORD PTR [rsp+1312]
	movaps	xmm8, XMMWORD PTR [rsp+1296]
	movaps	xmm9, XMMWORD PTR [rsp+1280]
	movaps	xmm10, XMMWORD PTR [rsp+1264]
	movaps	xmm11, XMMWORD PTR [rsp+1248]
	movaps	xmm12, XMMWORD PTR [rsp+1232]
	movaps	xmm13, XMMWORD PTR [rsp+1216]
	movaps	xmm14, XMMWORD PTR [rsp+1200]
	movaps	xmm15, XMMWORD PTR [rsp+1184]
	add	rsp, 1352				; 00000548H
	ret	0
?Log@@YAXPEBDAEBU?$_matrix@M@@@Z ENDP			; Log
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
msg$ = 48
err_code$ = 56
?LogWinErr@@YAXPEBDJ@Z PROC				; LogWinErr

; 264  : void LogWinErr			(const char *msg, long err_code)	{

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 265  : 	Msg					("%s: %s",msg,Debug.error2string(err_code)	);

	mov	edx, DWORD PTR err_code$[rsp]
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	call	?error2string@xrDebug@@QEAAPEBDJ@Z	; xrDebug::error2string
	mov	r8, rax
	mov	rdx, QWORD PTR msg$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_06DJHOIPC@?$CFs?3?5?$CFs?$AA@
	call	?Msg@@YAXPEBDZZ				; Msg

; 266  : }

	add	rsp, 40					; 00000028H
	ret	0
?LogWinErr@@YAXPEBDJ@Z ENDP				; LogWinErr
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
key$ = 8
base$ = 16
pval$ = 24
?LogXrayOffset@@YAXPEBDPEAX1@Z PROC			; LogXrayOffset

; 272  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 273  : #ifdef LUAICP_COMPAT
; 274  : 	u32 ofs = (u32)pval - (u32)base;
; 275  : 	MsgV	  ("XRAY_OFFSET", "XRAY_OFFSET: %30s = 0x%x base = 0x%p, pval = 0x%p ", key, ofs, base, pval);
; 276  : 	static OFFSET_UPDATER cbUpdater = NULL;
; 277  : 	HMODULE hDLL = GetModuleHandle("luaicp.dll");
; 278  : 	if (!cbUpdater && hDLL)
; 279  : 		cbUpdater = (OFFSET_UPDATER) GetProcAddress(hDLL, "UpdateXrayOffset");
; 280  : 
; 281  : 	if (cbUpdater)
; 282  : 		cbUpdater(key, ofs);
; 283  : #endif
; 284  : }

	ret	0
?LogXrayOffset@@YAXPEBDPEAX1@Z ENDP			; LogXrayOffset
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\log.cpp
_TEXT	SEGMENT
?GetLogCB@@YAP6AXPEBD@ZXZ PROC				; GetLogCB

; 294  : 	return LogCB;

	mov	rax, QWORD PTR LogCB

; 295  : }

	ret	0
?GetLogCB@@YAP6AXPEBD@ZXZ ENDP				; GetLogCB
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAAEAVshared_str@@_K@Z
_TEXT	SEGMENT
_Tmp$1 = 32
_Parg$ = 40
$T2 = 48
$T3 = 56
this$ = 80
_Pos$ = 88
??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAAEAVshared_str@@_K@Z PROC ; xr_vector<shared_str,xalloc<shared_str> >::operator[], COMDAT

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

$LN24:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
$LN3@operator:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN3@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Parg$[rsp], rax

; 306  : 		{	// construct with pointer _Parg

	mov	r8, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Parg$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAA@PEAVshared_str@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >

; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;

	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR _Tmp$1[rsp], rax

; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;

	mov	rdx, QWORD PTR _Pos$[rsp]
	lea	rcx, QWORD PTR _Tmp$1[rsp]
	call	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator+=

; 367  : 		return (_Tmp += _Off);

	mov	rax, QWORD PTR _Tmp$1[rsp]
	mov	QWORD PTR $T3[rsp], rax

; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);

	lea	rcx, QWORD PTR $T3[rsp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBAAEBVshared_str@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator*
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	add	rsp, 72					; 00000048H
	ret	0
??A?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAAEAVshared_str@@_K@Z ENDP ; xr_vector<shared_str,xalloc<shared_str> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?reserve@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?reserve@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAX_K@Z PROC ; std::vector<shared_str,xalloc<shared_str> >::reserve, COMDAT

; 999  : 		{	// determine new minimum length of allocated storage

$LN27:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1000 : 		if (capacity() < _Count)

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEBA_KXZ ; std::vector<shared_str,xalloc<shared_str> >::capacity
	cmp	rax, QWORD PTR _Count$[rsp]
	jae	SHORT $LN2@reserve

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEBA_KXZ ; std::vector<shared_str,xalloc<shared_str> >::max_size
	cmp	rax, QWORD PTR _Count$[rsp]
	jae	SHORT $LN1@reserve

; 1003 : 				_Xlen();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Xlen@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@IEBAXXZ ; std::vector<shared_str,xalloc<shared_str> >::_Xlen
$LN1@reserve:

; 1004 : 			_Reallocate(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Reallocate@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@IEAAX_K@Z ; std::vector<shared_str,xalloc<shared_str> >::_Reallocate
$LN2@reserve:
$LN4@reserve:

; 1005 : 			}
; 1006 : 		}

	add	rsp, 40					; 00000028H
	ret	0
?reserve@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAX_K@Z ENDP ; std::vector<shared_str,xalloc<shared_str> >::reserve
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAXAEBVshared_str@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Idx$3 = 40
<_Args_0>$ = 48
_Ptr$ = 56
this$ = 64
this$ = 96
_Val$ = 104
?push_back@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAXAEBVshared_str@@@Z PROC ; std::vector<shared_str,xalloc<shared_str> >::push_back, COMDAT

; 1243 : 		{	// insert element at end

$LN151:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1244 : 		if (_Inside(_STD addressof(_Val)))

	mov	rdx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Inside@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@IEBA_NPEBVshared_str@@@Z ; std::vector<shared_str,xalloc<shared_str> >::_Inside
	movzx	eax, al
	test	eax, eax
	je	$LN4@push_back

; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Val$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 3
	mov	QWORD PTR _Idx$3[rsp], rax

; 1247 : 			if (this->_Mylast == this->_Myend)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Reserve@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@IEAAX_K@Z ; std::vector<shared_str,xalloc<shared_str> >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@IEBAXPEAVshared_str@@0@Z ; std::vector<shared_str,xalloc<shared_str> >::_Orphan_range

; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Idx$3[rsp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR <_Args_0>$[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Ptr$[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<shared_str,xalloc<shared_str> > >::_Getal
	mov	QWORD PTR this$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR <_Args_0>$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?construct@?$xalloc@Vshared_str@@@@QEAAXPEAVshared_str@@AEBV2@@Z ; xalloc<shared_str>::construct
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1252 : 			++this->_Mylast;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1253 : 			}
; 1254 : 		else

	jmp	SHORT $LN2@push_back
$LN4@push_back:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Reserve@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@IEAAX_K@Z ; std::vector<shared_str,xalloc<shared_str> >::_Reserve
$LN1@push_back:

; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@IEBAXPEAVshared_str@@0@Z ; std::vector<shared_str,xalloc<shared_str> >::_Orphan_range

; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<shared_str,xalloc<shared_str> > >::_Getal
	mov	r8, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, rax
	call	??$construct@Vshared_str@@AEBV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEBV2@@Z ; std::_Wrap_alloc<xalloc<shared_str> >::construct<shared_str,shared_str const & __ptr64>

; 1261 : 			++this->_Mylast;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax
$LN2@push_back:

; 1262 : 			}
; 1263 : 		}

	add	rsp, 88					; 00000058H
	ret	0
?push_back@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAAXAEBVshared_str@@@Z ENDP ; std::vector<shared_str,xalloc<shared_str> >::push_back
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_Parg$ = 32
this$ = 64
__$ReturnUdt$ = 72
?begin@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@2@XZ PROC ; std::vector<shared_str,xalloc<shared_str> >::begin, COMDAT

; 1024 : 		{	// return iterator for beginning of mutable sequence

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Parg$[rsp], rax

; 306  : 		{	// construct with pointer _Parg

	mov	r8, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Parg$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAA@PEAVshared_str@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1026 : 		}

	add	rsp, 56					; 00000038H
	ret	0
?begin@?$vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@2@XZ ENDP ; std::vector<shared_str,xalloc<shared_str> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBAAEAVshared_str@@XZ
_TEXT	SEGMENT
this$ = 48
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBAAEAVshared_str@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator*, COMDAT

; 323  : 		{	// return designated object

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rcx, QWORD PTR this$[rsp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBAAEBVshared_str@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator*

; 325  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBAAEAVshared_str@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
_Tmp$ = 32
this$ = 64
__$ReturnUdt$ = 72
_Off$ = 80
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator+, COMDAT

; 365  : 		{	// return this + integer

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 366  : 		_Myiter _Tmp = *this;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Tmp$[rsp], rax

; 360  : 		*(_Mybase *)this += _Off;

	mov	rdx, QWORD PTR _Off$[rsp]
	lea	rcx, QWORD PTR _Tmp$[rsp]
	call	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator+=

; 367  : 		return (_Tmp += _Off);

	mov	rax, QWORD PTR _Tmp$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 368  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator+
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAA@PEAVshared_str@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Pvector$ = 64
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAA@PEAVshared_str@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >, COMDAT

; 306  : 		{	// construct with pointer _Parg

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR _Pvector$[rsp]
	mov	rdx, QWORD PTR _Parg$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAA@PEAVshared_str@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >

; 307  : 		}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAA@PEAVshared_str@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator+=, COMDAT

; 359  : 		{	// increment by integer

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 360  : 		*(_Mybase *)this += _Off;

	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator+=

; 361  : 		return (*this);

	mov	rax, QWORD PTR this$[rsp]

; 362  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@Vshared_str@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<shared_str> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@XZ
_TEXT	SEGMENT
$T1 = 32
tv73 = 40
ptr$ = 48
??$xr_new@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@XZ PROC ; xr_new<xr_vector<shared_str,xalloc<shared_str> > >, COMDAT

; 67   : {

$LN17:
	sub	rsp, 72					; 00000048H

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	edx, 24
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	QWORD PTR ptr$[rsp], rax

; 69   : 	return new (ptr) T();

	mov	rdx, QWORD PTR ptr$[rsp]
	mov	ecx, 24
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN3@xr_new
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAA@XZ ; xr_vector<shared_str,xalloc<shared_str> >::xr_vector<shared_str,xalloc<shared_str> >
	mov	QWORD PTR tv73[rsp], rax
	jmp	SHORT $LN4@xr_new
$LN3@xr_new:
	mov	QWORD PTR tv73[rsp], 0
$LN4@xr_new:
	mov	rax, QWORD PTR tv73[rsp]

; 70   : }

	add	rsp, 72					; 00000048H
	ret	0
??$xr_new@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@XZ ENDP ; xr_new<xr_vector<shared_str,xalloc<shared_str> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_delete@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z
_TEXT	SEGMENT
$T1 = 32
ptr$ = 64
??$xr_delete@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z PROC ; xr_delete<xr_vector<shared_str,xalloc<shared_str> > >, COMDAT

; 150  : {

$LN18:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H

; 151  : 	if (ptr) 

	mov	rax, QWORD PTR ptr$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN1@xr_delete

; 152  : 	{
; 153  : 		xr_special_free<xrcore::is_polymorphic<T>::result,T>()(ptr);

	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	mov	rdx, QWORD PTR ptr$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	??R?$xr_special_free@$0A@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@QEAAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z ; xr_special_free<0,xr_vector<shared_str,xalloc<shared_str> > >::operator()

; 154  : 		ptr = NULL;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR [rax], 0
$LN1@xr_delete:

; 155  : 	}
; 156  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$xr_delete@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@YAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z ENDP ; xr_delete<xr_vector<shared_str,xalloc<shared_str> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBVshared_str@@@std@@YAPEBVshared_str@@AEBV1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBVshared_str@@@std@@YAPEBVshared_str@@AEBV1@@Z PROC ; std::addressof<shared_str const >, COMDAT

; 92   : 	{	// return address of _Val

	mov	QWORD PTR [rsp+8], rcx

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, QWORD PTR _Val$[rsp]

; 96   : 	}

	ret	0
??$addressof@$$CBVshared_str@@@std@@YAPEBVshared_str@@AEBV1@@Z ENDP ; std::addressof<shared_str const >
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@Vshared_str@@AEAV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEAV2@@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@Vshared_str@@AEAV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEAV2@@Z PROC ; std::_Wrap_alloc<xalloc<shared_str> >::construct<shared_str,shared_str & __ptr64>, COMDAT

; 868  : 		void construct(_Ty *_Ptr,

$LN32:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR <_Args_0>$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?construct@?$xalloc@Vshared_str@@@@QEAAXPEAVshared_str@@AEBV2@@Z ; xalloc<shared_str>::construct

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??$construct@Vshared_str@@AEAV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEAV2@@Z ENDP ; std::_Wrap_alloc<xalloc<shared_str> >::construct<shared_str,shared_str & __ptr64>
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@Vshared_str@@AEBV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEBV2@@Z
_TEXT	SEGMENT
<_Args_0>$ = 32
<_Args_0>$ = 40
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@Vshared_str@@AEBV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEBV2@@Z PROC ; std::_Wrap_alloc<xalloc<shared_str> >::construct<shared_str,shared_str const & __ptr64>, COMDAT

; 868  : 		void construct(_Ty *_Ptr,

$LN32:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBVshared_str@@@std@@YAAEBVshared_str@@AEBV1@@Z ; std::forward<shared_str const & __ptr64>
	mov	QWORD PTR <_Args_0>$[rsp], rax

; 339  : 		}
; 340  : 
; 341  : 	template<class _Ty,
; 342  : 		class _Objty,
; 343  : 		class... _Types>
; 344  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 345  : 			_Types&&... _Args)
; 346  : 			-> void
; 347  : 		{	// call default version
; 348  : 		::new (static_cast<void *>(_Ptr))
; 349  : 			_Objty(_STD forward<_Types>(_Args)...);
; 350  : 		}
; 351  : 
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 442  : 
; 443  : 	template<class _Other>
; 444  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 445  : 
; 446  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 447  : 		{	// allocate array of _Count elements
; 448  : 		return (_Al.allocate(_Count));
; 449  : 		}
; 450  : 
; 451  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 452  : 		const_void_pointer _Hint)
; 453  : 		{	// allocate array of _Count elements, with hint
; 454  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 455  : 		}
; 456  : 
; 457  : 	static void deallocate(_Alloc& _Al,
; 458  : 		pointer _Ptr, size_type _Count)
; 459  : 		{	// deallocate _Count elements at _Ptr
; 460  : 		_Al.deallocate(_Ptr, _Count);
; 461  : 		}
; 462  : 
; 463  : 	template<class _Ty,
; 464  : 		class... _Types>
; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBVshared_str@@@std@@YAAEBVshared_str@@AEBV1@@Z ; std::forward<shared_str const & __ptr64>
	mov	QWORD PTR <_Args_0>$[rsp], rax

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBVshared_str@@@std@@YAAEBVshared_str@@AEBV1@@Z ; std::forward<shared_str const & __ptr64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?construct@?$xalloc@Vshared_str@@@@QEAAXPEAVshared_str@@AEBV2@@Z ; xalloc<shared_str>::construct

; 873  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$construct@Vshared_str@@AEBV1@@?$_Wrap_alloc@V?$xalloc@Vshared_str@@@@@std@@QEAAXPEAVshared_str@@AEBV2@@Z ENDP ; std::_Wrap_alloc<xalloc<shared_str> >::construct<shared_str,shared_str const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@QEAAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z
_TEXT	SEGMENT
this$ = 32
this$ = 64
ptr$ = 72
??R?$xr_special_free@$0A@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@QEAAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z PROC ; xr_special_free<0,xr_vector<shared_str,xalloc<shared_str> > >::operator(), COMDAT

; 142  : 	{

$LN15:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 143  : 		ptr->~T			();

	mov	rax, QWORD PTR ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR this$[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAA@XZ
	xor	eax, eax
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@operator
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX@Z				; operator delete
$LN3@operator:

; 144  : 		Memory.mem_free	(ptr);

	mov	rax, QWORD PTR ptr$[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	call	?mem_free@xrMemory@@QEAAXPEAX@Z		; xrMemory::mem_free

; 145  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??R?$xr_special_free@$0A@V?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@@QEAAXAEAPEAV?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@@Z ENDP ; xr_special_free<0,xr_vector<shared_str,xalloc<shared_str> > >::operator()
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAPEAXI@Z PROC ; xr_vector<shared_str,xalloc<shared_str> >::`scalar deleting destructor', COMDAT
$LN13:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN1@scalar
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX@Z				; operator delete
$LN1@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$xr_vector@Vshared_str@@V?$xalloc@Vshared_str@@@@@@QEAAPEAXI@Z ENDP ; xr_vector<shared_str,xalloc<shared_str> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAVshared_str@@@std@@YAAEAVshared_str@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAVshared_str@@@std@@YAAEAVshared_str@@AEAV1@@Z PROC ; std::forward<shared_str & __ptr64>, COMDAT

; 1504 : 	{	// forward an lvalue

	mov	QWORD PTR [rsp+8], rcx

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, QWORD PTR _Arg$[rsp]

; 1506 : 	}

	ret	0
??$forward@AEAVshared_str@@@std@@YAAEAVshared_str@@AEAV1@@Z ENDP ; std::forward<shared_str & __ptr64>
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@Vshared_str@@AEAV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@Vshared_str@@AEAV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z PROC ; std::allocator_traits<xalloc<shared_str> >::construct<shared_str,shared_str & __ptr64>, COMDAT

; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,

$LN28:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR <_Args_0>$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?construct@?$xalloc@Vshared_str@@@@QEAAXPEAVshared_str@@AEBV2@@Z ; xalloc<shared_str>::construct

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??$construct@Vshared_str@@AEAV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z ENDP ; std::allocator_traits<xalloc<shared_str> >::construct<shared_str,shared_str & __ptr64>
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@Vshared_str@@AEBV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z
_TEXT	SEGMENT
<_Args_0>$ = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@Vshared_str@@AEBV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z PROC ; std::allocator_traits<xalloc<shared_str> >::construct<shared_str,shared_str const & __ptr64>, COMDAT

; 465  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,

$LN28:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBVshared_str@@@std@@YAAEBVshared_str@@AEBV1@@Z ; std::forward<shared_str const & __ptr64>
	mov	QWORD PTR <_Args_0>$[rsp], rax

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBVshared_str@@@std@@YAAEBVshared_str@@AEBV1@@Z ; std::forward<shared_str const & __ptr64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?construct@?$xalloc@Vshared_str@@@@QEAAXPEAVshared_str@@AEBV2@@Z ; xalloc<shared_str>::construct

; 470  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$construct@Vshared_str@@AEBV1@@?$allocator_traits@V?$xalloc@Vshared_str@@@@@std@@SAXAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z ENDP ; std::allocator_traits<xalloc<shared_str> >::construct<shared_str,shared_str const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z
_TEXT	SEGMENT
__formal$ = 48
_Al$ = 56
_Ptr$ = 64
<_Args_0>$ = 72
??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<shared_str>,shared_str,shared_str & __ptr64>, COMDAT

; 337  : 		{	// call allocator supplied version

$LN24:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	r8, QWORD PTR <_Args_0>$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?construct@?$xalloc@Vshared_str@@@@QEAAXPEAVshared_str@@AEBV2@@Z ; xalloc<shared_str>::construct

; 339  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEAV3@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<shared_str>,shared_str,shared_str & __ptr64>
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEBV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z
_TEXT	SEGMENT
__formal$ = 48
_Al$ = 56
_Ptr$ = 64
<_Args_0>$ = 72
??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEBV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<shared_str>,shared_str,shared_str const & __ptr64>, COMDAT

; 337  : 		{	// call allocator supplied version

$LN24:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBVshared_str@@@std@@YAAEBVshared_str@@AEBV1@@Z ; std::forward<shared_str const & __ptr64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?construct@?$xalloc@Vshared_str@@@@QEAAXPEAVshared_str@@AEBV2@@Z ; xalloc<shared_str>::construct

; 339  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??$_Fn@V?$xalloc@Vshared_str@@@@Vshared_str@@AEBV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@Vshared_str@@@@PEAVshared_str@@AEBV3@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<shared_str>,shared_str,shared_str const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
_TEXT	SEGMENT
_Time$ = 8
localtime PROC

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

	rex_jmp	QWORD PTR __imp__localtime64
localtime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
_TEXT	SEGMENT
_Time$ = 8
time	PROC

; 133  :     return _time64(_Time);

	rex_jmp	QWORD PTR __imp__time64
time	ENDP
_TEXT	ENDS
END
